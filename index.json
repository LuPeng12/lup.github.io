[{"categories":["Java"],"content":"了解Webflux.","date":"2023-01-05","objectID":"/webflux/","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"Spring WebFlux 是一个异步非阻塞式 IO 模型. WebFlux ","date":"2023-01-05","objectID":"/webflux/:0:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"前置知识 Lambda（() -\u003e {}）、函数式接口（@FunctionalInterface，Function，Supplier，Consumer，Predicate）、方法引用（::） JDK8 Stream JDK9 Reactive Stream(Backpressure、Publisher、Subscriber、Processor、Subscription) ","date":"2023-01-05","objectID":"/webflux/:1:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"一、什么是 WebFlux？ Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问，Spring WebFlux 可以有效提升系统的吞吐量和伸缩性。 ","date":"2023-01-05","objectID":"/webflux/:2:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"二、什么是 Reactor？ Spring Reactor 是 Pivotal 团队基于反应式编程实现的一种方案，这是一种非阻塞、由事件驱动的编程方案，它使用函数式编程实现。 换句话说，大家可以把 Reactor 理解为 Java8 中的 Stream + Java9 中的 Reactive Stream。 Reactor是一个响应式流，它也有对应的发布者(Publisher )，Reactor的发布者用两个类来表示： Mono（返回 0 | 1 个元素） Flux（返回 0 | n 个元素） ","date":"2023-01-05","objectID":"/webflux/:3:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"三、Mono ​ Mono 作为发布者，发出一个或零个消息完成或发生错误后终止。若因为某个原因突然终止，它会抛出一个错误并立即终止。 public Person findCurrentUser() { if (true) return new Person(\"Jane\", \"Doe\"); else return null; } //Java 8 public Optional\u003cPerson\u003e findCurrentUser() { if (true) return Optional.of(new Person(\"Jane\", \"Doe\")); else return Optional.empty(); } //Reactive Stream public Mono\u003cPerson\u003e findCurrentUser() { if (true) return Mono.just(new Person(\"Jane\", \"Doe\")); else return Mono.empty(); } public class MonoTest1 { @GetMapping(\"/hello\") public String hello() { return \"hello\"; } @GetMapping(\"/hello2\") public Mono\u003cString\u003e hello2() { return Mono.just(\"hello Mono\"); } } 上面的例子看不出来区别，改进一下如下： @RestController public class MonoTest2 { @GetMapping(\"/helloDefault\") public String hello() { long start = System.currentTimeMillis(); String msg = getReturn(\"\"); System.out.println(\"普通接口耗时：\" + (System.currentTimeMillis() - start)); return msg; } @GetMapping(\"/helloMono\") public Mono\u003cString\u003e hello2() { long start = System.currentTimeMillis(); Mono\u003cString\u003e msg = Mono.fromSupplier(() -\u003e getReturn(\"Mono\")); System.out.println(\"WebFlux 接口耗时：\" + (System.currentTimeMillis() - start)); return msg; } private String getReturn(String type){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return \"Hello \" + type; } } ​ 从调用者（浏览器）的角度而言，是感知不到有什么变化的，因为都是得等待2s才返回数据。但是，从服务端的日志我们可以看出，WebFlux是直接返回Mono对象的，而SpringMVC一直同步阻塞2s，线程才返回。 ​ WebFlux提供了两种使用模式：①SpringMVC 注解；②Functional Endpoints（Lambda + 流式编程）。上面是 WebFlux 的注解（Spring MVC）使用方式，下面是 WebFlux 函数式使用方式： //handler 相当于 controller，官方定义是处理，就是写逻辑代码的地方。 //ServerResponse 是对响应的封装，可以设置响应状态，响应头，响应正文。Ok-200响应码 //MediaType 枚举是代表这文本内容类型、返回的是 String 的对象。 //这里用 Mono 作为返回对象，是因为返回包含了一个 ServerResponse 对象，而不是多个元素 @Component public class MonoTest3 { public Mono\u003cServerResponse\u003e monoTest3(ServerRequest request){ return ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(\"hello Mono by Handler\"); } } //router 相当于RequestMapping() ，配置映射，官方定义是路由。 //在使用 WebFlux 的 Spring Boot 应用中，只需要创建 RouterFunction 类型的 bean，就会被自动注册来处理请求并调用相应的 HandlerFunction。 @Configuration public class MonoTestRouter { @Bean public RouterFunction\u003cServerResponse\u003e CareerInfo(MonoTest3 handler) { return RouterFunctions.route().path(\"/monoTest\", b1 -\u003e b1.nest(RequestPredicates.accept(MediaType.APPLICATION_JSON), b2 -\u003e b2.GET(\"/byHandler\", handler::monoTest3) )) .build(); } } ","date":"2023-01-05","objectID":"/webflux/:4:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"四、Flux ​ Flux 作为发布者，发出多个或零个消息完成或发生错误后终止。 public List\u003cPerson\u003e findAll() { return Arrays.asList( new Person(\"Jane\", \"Doe\"), new Person(\"John\", \"Doe\") ); } //Java 8 public Stream\u003cPerson\u003e findAll() { return Stream.of( new Person(\"Jane\", \"Doe\"), new Person(\"John\", \"Doe\") ); } //Reactive Stream public Flux\u003cPerson\u003e findAll() { return Flux.just( new Person(\"Jane\", \"Doe\"), new Person(\"John\", \"Doe\") ); } @RestController public class FluxTest1 { @GetMapping(value = \"/helloFlux\",produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u003cString\u003e flux() { Flux\u003cString\u003e flux = Flux.fromArray(new String[]{\"java\",\"lambda\",\"stream\",\"back pressure\"}) .map(s -\u003e { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return \"my-\u003edata-\u003e\" + s; }); return flux; } } ","date":"2023-01-05","objectID":"/webflux/:5:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"五、WebFlux 实现增删改查 ​ WebFlux + R2DBC + MySQL @Component public class WebFluxCURD { private DatabaseClient dbClient; public WebFluxCURD(@Qualifier(\"DBClient\") DatabaseClient client){ this.dbClient = client; } public Mono\u003cServerResponse\u003e createTest(ServerRequest request){ String sql = \"INSERT INTO sysservice (sname,sorder,snote) VALUES ('测试',1,'备注备注备注')\"; return ZZSR2DBCService.insertUpdateDelete(dbClient,sql) .flatMap(d -\u003e { String result = d \u003e 0 ? \"成功\" : \"失败\"; return ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(\"数据添加\" + result); }); } public Mono\u003cServerResponse\u003e updateTest(ServerRequest request){ String sql = \"UPDATE sysservice SET snote = '修改备注备注备注' WHERE sname = '测试'\"; return ZZSR2DBCService.insertUpdateDelete(dbClient,sql) .flatMap(d -\u003e { String result = d \u003e 0 ? \"成功\" : \"失败\"; return ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(\"数据修改\" + result); }); } public Mono\u003cServerResponse\u003e retrieveTest(ServerRequest request){ String sql = \"SELECT sname FROM sysservice\"; return ZZSR2DBCService.getJsonArray(dbClient,sql) .flatMap(d -\u003e ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(d.toString()) ); } public Mono\u003cServerResponse\u003e deleteTest(ServerRequest request){ String sql = \"DELETE FROM sysservice WHERE sname = '测试'\"; return ZZSR2DBCService.insertUpdateDelete(dbClient,sql) .flatMap(d -\u003e { String result = d \u003e 0 ? \"成功\" : \"失败\"; return ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(\"数据删除\" + result); }); } } ​ 其中，WebFlux 获取 GET 请求参数的方式为： //获取所有的 GET 请求参数 Map\u003cString,String\u003e queryDatas = request.queryParams().toSingleValueMap(); //获取某个 GET 请求参数 String queryData = request.queryParam(\"Data1\").toString(); ​ 获取 POST 请求参数的方式为： Mono\u003cMap\u003cString,String\u003e\u003e formDatas = request.formData().map(MultiValueMap::toSingleValueMap); ","date":"2023-01-05","objectID":"/webflux/:6:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"六、WebFlux 复杂使用 ","date":"2023-01-05","objectID":"/webflux/:7:0","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"1 Mono.zipWith() ​ 把当前流中的元素与另外一个流中的元素按照一对一的方式进行合并。 public Mono\u003cServerResponse\u003e monoZipWith(ServerRequest request){ return Mono.just(\"This is Mono.zipWith(),\") .flatMap(f1 -\u003e { //Do something ... return Mono.just(\"mono1.zipWith(mono2)\") .flatMap(f2 -\u003e ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(f1 + f2)); }); } public Mono\u003cServerResponse\u003e monoZipWith(ServerRequest request){ Mono\u003cString\u003e mono1 = Mono.just(\"This is Mono.zipWith(),\"); Mono\u003cString\u003e mono2 = Mono.just(\"mono1.zipWith(mono2)\"); return mono1.zipWith(mono2) .flatMap(d -\u003e ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(d.getT1() + d.getT2()) ); } ","date":"2023-01-05","objectID":"/webflux/:7:1","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"2 Mono.zip() ​ 合并多个数据源，最多允许同时合并 8 个数据源。注意：其中任意一个 Mono 为空最终都将得到空 Mono。 //Tuple 元组 public static \u003cT1, T2\u003e Mono\u003cTuple2\u003cT1, T2\u003e\u003e zip(Mono\u003c? extends T1\u003e p1, Mono\u003c? extends T2\u003e p2) { return zip(p1, p2, Flux.tuple2Function()); } public Mono\u003cServerResponse\u003e monoZip(ServerRequest request){ return Mono.just(\"This is Mono.zip()\") .flatMap(f1 -\u003e { //Do something ... return Mono.just(\"Victory or Defeat\") .flatMap(f2 -\u003e { //Do something ... return Mono.just(\"Data source 3\") .flatMap(f3 -\u003e { //Do something ... return ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(f1 + \",\" + f2 + \"?\" + f3); }); }); }); } public Mono\u003cServerResponse\u003e monoZip(ServerRequest request){ Mono\u003cString\u003e mono1 = Mono.just(\"This is Mono.zip()\"); Mono\u003cString\u003e mono2 = Mono.just(\"Victory or Defeat\"); Mono\u003cString\u003e mono3 = Mono.empty(); return Mono.zip(mono1,mono2,mono3) .flatMap(d -\u003e ServerResponse .ok() .contentType(MediaType.APPLICATION_JSON) .bodyValue(d.getT1() + \" \" + d.getT2() + d.getT3()) ); } ​ 上述代码中，产生 mono1、mono2、mono3 的过程是 并行 的，因此可以加快程序的执行。 ","date":"2023-01-05","objectID":"/webflux/:7:2","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"3 Mono.map() 与 Mono.flatMap() ​ Mono.flatMap()，入参 Function 的返回值要求是一个 Mono。 ​ Mono.map()，入参 Function 只要求返回一个普通对象。 ​ 因此，要将这些调用串联为一个整体链式调用，就必须使用 flatMap，而不是 map。 ​ 实例：考生考卷压缩导出 //试卷信息——试卷名称、试卷总分、考试时间 Mono\u003cMap\u003cString,Object\u003e\u003e paperInfo = Mono.just(new HashMap\u003cString,Object\u003e()); //试卷明细——题型、大题序号、大题总分、包含小题数量 Mono\u003cJSONArray\u003e paperDetail = Mono.just(new JSONArray()); //考生信息——考生主键、考生姓名、考生考号 Mono\u003cList\u003cMap\u003cString, Object\u003e\u003e\u003e candidate = Mono.just(new ArrayList\u003cMap\u003cString,Object\u003e\u003e()); //session Mono\u003cWebSession\u003e sessionMono = request.session(); return Mono.zip(paperInfo,paperDetail,candidate,sessionMono) .flatMap(d -\u003e { if (d.getT2().length() == 0 || d.getT3().size() == 0) return ServerResponse.status(500).bodyValue(\"数据库繁忙，请稍后再试！\"); return createCandidatePaper(sFullParams,d); }); Mono\u003cJSONArray\u003e arrayD = Mono.just(new JSONArray());//单选题 Mono\u003cJSONArray\u003e arrayM = Mono.just(new JSONArray());//多选题 Mono\u003cJSONArray\u003e arrayJ = Mono.just(new JSONArray());//判断题 Mono\u003cJSONArray\u003e arrayF = Mono.just(new JSONArray());//填空题 Mono\u003cJSONArray\u003e arrayS = Mono.just(new JSONArray());//简答题 Mono\u003cJSONArray\u003e arrayC = Mono.just(new JSONArray());//计算题 Mono\u003cJSONArray\u003e arrayA = Mono.just(new JSONArray());//材料分析题 //d.getT2()为某场考试考试题型信息 for (int i = 0; i \u003c d.getT2().length(); i ++){ JSONObject object = d.getT2().getJSONObject(i); String qtype = object.get(\"qtype\").toString();//试题类型 String qdtxh = object.get(\"qdtxh\").toString();//大题序号 String qdtsonsum = object.get(\"qdtsonsum\").toString();//包含小题个数 String qdtzf = object.get(\"qdtzf\").toString();//大题总分 //从数据库获取某考生对应题型的数据 Mono\u003cJSONArray\u003e qinfo = ZZSR2DBCService.getJsonArray(dbClient,getQuestionInfoByCandidate(qtype,euno),new HashMap\u003c\u003e(sFullParams)) .flatMap(a -\u003e { JSONObject objectTmp = new JSONObject(); objectTmp.put(\"qtype\",qtype); objectTmp.put(\"qdtxh\",qdtxh); objectTmp.put(\"qdtsonsum\",qdtsonsum); objectTmp.put(\"qdtzf\",qdtzf); a.put(a.length(),objectTmp); return Mono.just(a); }); //根据题型将考生考卷数据放入对应的Mono中 switch (qtype){ case \"D\": arrayD = qinfo;break; case \"M\": arrayM = qinfo;break; case \"J\": arrayJ = qinfo;break; case \"F\": arrayF = qinfo;break; case \"S\": arrayS = qinfo;break; case \"C\": arrayC = qinfo;break; case \"A\": arrayA = qinfo;break; } } return Mono.zip(arrayD, arrayM, arrayJ, arrayF, arrayS, arrayC, arrayA) .flatMap(f2 -\u003e { for (int i = 0; i \u003c d.getT2().length(); i ++){ JSONObject object = d.getT2().getJSONObject(i); String qtype = object.get(\"qtype\").toString(); int index = 0; //根据题型类别获取对应Mono中的数据 switch (qtype){ case \"D\": index = 0;break; case \"M\": index = 1;break; case \"J\": index = 2;break; case \"F\": index = 3;break; case \"S\": index = 4;break; case \"C\": index = 5;break; case \"A\": index = 6;break; } JSONArray array = (JSONArray) f2.get(index); if (array != null \u0026\u0026 array.length() \u003e 0) CreateQuestion(wordSer,document,array); } //往word中写入考卷数据 return Mono.just(f2.size()); }); ","date":"2023-01-05","objectID":"/webflux/:7:3","tags":["Java","Spring"],"title":"Webflux","uri":"/webflux/"},{"categories":["Java"],"content":"JVM内存模型和死锁","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"JVM内存模型和死锁描述 JVM内存模型和死锁 ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:0:0","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"cpu多核缓存架构 目的：解决cpu与内存速度不匹配问题 cpu分为三级缓存，每个cpu都有L1，L2缓存，但L3缓存是多核共用的。 cpu查找数据的顺序：cpu-\u003eL1-\u003eL2-\u003eL3-\u003e内存-\u003e硬盘。 cpu每次读数据会读取与其相邻的64个字节的数据，叫做【缓存行】-计算机局部性原理 多级缓存问题 可见性问题（一个线程修改的值对其他线程不可见，导致数据不一致） 资源的争夺问题（多个线程修改相同的资源时） 另外除增加高速缓存之外，为了使处理器内部的运算单元尽量被充分利用。处理器可能会对输入的代码进行【乱序执行】，优化处理器 会在计算之后将乱序执行的结果【进行重组】，保证该结果与顺序 执行的结果是一致的，但并不保证程序中各个语句的先后执行顺序 与输入输入代码中的顺序一致。因此如果存在一个计算任务，依赖 于另外一个依赖任务的中间，结果那么顺序性不能靠代码的先后顺 序来保证。 Java虚拟机的即时编译器中也有【指令重排】的优化。 ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:0:1","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"JMM-java内存模型 内存结构与内存模型 java内存结构：内存结构由Java虚拟机规范定义, 其描述的是Java程序执行过程中, 由JVM管理的不同的数据区域。包括程序计数器、虚拟机栈、本地方法栈、Java堆、方法区。 java内存模型： Java虚拟规范中曾经试图定义一种Java内存模型，来屏蔽各种硬件和操作系统的内存访问之间的差异，以实现让Java程序在各种平台上都能达到一致的内存访问效果。sun（“一次编写，到处运行”（Write once, run anywhere、WORA，有时也作“write once, run everywhere”、WORE），在此之前，主流程序语言直接使用物理内存和操作系统的内存模型，会由于不同平台的内存模型的差异，可能导致程序在一套平台上发挥完全正常，而在另一套平台上并发觉经常发生错误，所以在某种常见的场景下，必须针对平台来进行代码的编写。 目的：屏蔽各种硬件和操作系统的内存访问之间的差异，以实现让Java程序在各种平台上都能达到一致的内存访问效果 这里的内存模型和我们的运行时数据区是从不同的角度去分析java对内存的使用的（）。两者表达的含义和目的不同。 在java内存模型当中一样会存在可见性和指令重排的问题。 存在的问题 指令重排 在指令重排中，有一个经典的as-if-serial语义，计算机会安装该语义对指令进行优化，其目的是不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。 { int a = 1; int b = 2; a+b; } 单线程情况是不会出现问题，但多线程可能出这个线程依赖另一个线程的数据，它们之间是无感知的所以会出现问题。 多线程下指令重排可能会导致一些问题，乱序执行导致结果不一致 解决指令重排的方法是使用内存屏障（就是一条指令）：在java语言中我们可以使用volatile关键字来保证一个变量在一次读写操作时的避免指令重排 【内存屏障】是在我们的读写操作之前加入一条指令当cpu碰到这条指令后必须等到前边的指令执行完成 才能继续执行下一条指令。 1 ↓ ---Lock（必须等1执行结束） 2 ↓ 3 可见性 public class visible { private static volatile boolean flag=false; //缓存中的flag public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-\u003e{ while (!flag){ } System.out.println(\"看见我了吗！\"); }); t1.start(); Thread.sleep(2000); flag = true; //主存中已修改的flag } } 如不加voiatile关键字，thread线程一直在高速缓存中读取flag的值，不能感知主线程已经修改了flag的值而退出循环。 volatile能强制对改变量的读写直接在主存中操作，从而解决了不可见的问题。 写操作是，立刻强制刷在主存，并且将其他缓存区域的值设置为不可用。 happens-before（先行发生） JMM用【happens-before】的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见， 那么这两个操作之间必须要存在happens-before关系 。 总结就是规定了哪些写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结： 程序顺序规则 ： 在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。 若Ａ操作书写顺序在Ｂ操作之前，则线程中Ａ操作早于Ｂ操作执行 虽然程序顺序规则规定了若A操作的书写顺序在B操作之前，则线程中A操作早于B操作执行，但是这并不意味着单线程中不存在指令重排。 在单线程中，处理器仍然可能对指令的执行顺序进行优化，以提高程序的性能。这种指令重排不会影响程序的正确性，因为它仍然遵循HAPPENS-BEFORE原则。也就是说，即使处理器对指令的执行顺序进行了优化，它仍然会确保程序的执行结果与程序顺序规则的要求一致。 因此，单线程中仍然可能存在指令重排，但只要它遵循HAPPENS-BEFORE原则，就不会影响程序的正确性。 volatile变量规则： 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。 线程对volatile变量的写，对接下来其他线程对该变量的读可见 volatile static int x; new Thread(() -\u003e{ x = 10; },\"t1\").start(); new Thread(() -\u003e{ System.out.println(x); },\"t2\").start(); 线程启动规则： Thread对象的start()方法先行发生于此线程的每个一个动作。 线程 start 前对变量的写，对该线程开始后对该变量的读可见 static int x; x = 10; new Thread(() -\u003e{ System.out.println(x); },\"t2\").start(); 线程终止规则： 线程中的所有操作都先行发生于对此线程的终止检测 线程结束前对变量的写，对其他线程得知它结束后的读可见（比如其他线程调用t1.isAlive() 或 t1.join()等待它结束） public class end { static int x; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e{ x = 10; },\"t1\"); t1.start(); System.out.println(x); // while (true){ // if (!t1.isAlive()){ // System.out.println(\"t1线程结束，获取x的值\"+x); // break; // } // } //t1.join(); // System.out.println(x); } } 线程中断规则： 对线程interrupt()方法一定早于检测到线程的中断信号。 线程t1打断t2(interrupt) 前对变量的写，对于其他线程得知t2 被打断后对变量的读可见（通过t2.interrupted 或t2.isInterrupted） private static boolean stop = false; public static void main(String[] args) { Thread getter = new Thread(new Runnable() { @Override public void run() { while (true) { if (Thread.currentThread().isInterrupted()) { if (stop) { System.out.println(\"getter stopped.\"); break; } } } } }, \"getter\"); Thread updater = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } stop = true; getter.interrupt(); System.out.println(\"updater set stop true.\"); } }, \"updater\"); updater.start(); getter.start(); } 锁定规则 ： 一个unlock操作先行发生于后面对同一个锁的lock操作。 线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对该变量的读可见 static int x; static Object m = new Object(); new Thread(() -\u003e{ synchronized (m){ x = 10; } },\"t1\").start(); new Thread(() -\u003e{ synchronized (m){ System.out.println(x); } },\"t2\").start(); 传递规则： 如果A早于B，B早于C，那么A一定早于C “x=42” 先于读变量“v=true” 如果线程B读到了“v=true”，那么线程A设置的“x=42”对线程B是可见的。也就是说，线程B能看到 “x == 42 对象终结规则： 一个对象的初始化完成先行发生于他的finalize()方法 对象的构造方法和静态块执行是先与finalize()的，也就是说一个对象的构造方法结束所产生的影响，对于它的finalize()方法开始执行是可见的。 public class HappensBeforeTest { public HappensBeforeTest(){ System.out.println(\"初","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:0:2","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"死锁 ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:1:0","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"1.概念 指两个或两个以上的线程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 如下图，线程A和线程B都尝试获取对方持有的锁，但是又不释放自己所持有的锁就会陷入死锁。 ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:1:1","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"2.死锁产生原因 四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 常见死锁 (1).交叉锁 一个线程thread1访问lock1（获得锁lock1），然后又访问lock2；另一个线程thread2访问lock2（锁住了 lock2），然后企图访问lock1；这时线程thread1因为线程thread2已经锁住lock2，它必须等待线程thread2 释放lock2才能继续，同样线程thread2要等线程thread1释放lock2才能继续，这样死锁就产生了。 public static void main(String[] args) { Object lock1 = new Object(); Object lock2 = new Object(); Thread thread1 = new Thread(() -\u003e { synchronized (lock1) { System.out.println(Thread.currentThread().getName() + \"获取了第一把锁\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"休息1s之后，尝试获取第二把锁\"); synchronized (lock2) { System.out.println(Thread.currentThread().getName() + \"获取第二把 锁\"); } } }); thread1.start(); Thread thread2 = new Thread(() -\u003e { synchronized (lock2){ System.out.println(Thread.currentThread().getName() + \"获取了第二把锁\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"休息1s之后，尝试获取第一把锁\"); synchronized (lock1){ System.out.println(Thread.currentThread().getName() + \"获取第一把 锁\"); } } }); thread2.start(); } (2).内存不足 线程A和线程B都需要内存40MB，现在线程A已有10MB，还需要30MB；线程B已有10MB，还需要30MB， 但是系统内存只剩余20MB，因此两个线程都在等对方释放内存来满足自己，死锁就产生了。 (3).一问一答的数据交换 服务器端（server）和客户端（client），server等待client的访问；client发送请求到server，等待接收数据；由于网络的原因，server错过了client的请求，因此server等待client的访问，client等待接收数据，产生死锁。 (4).死循环引起的死锁 某个线程，由于编码问题，在对资源加锁后，陷入死循环，导致线程无法释放锁。 public static void main(String[] args) { HashMap\u003cString, String\u003e map = new HashMap\u003c\u003e(); for(int i=0; i\u003c2; i++){ new Thread(() -\u003e { synchronized (lock1) { System.out.println(Thread.currentThread().getName() + \"获取了第一把锁\"); for(int i = 0; i \u003c Integer.MAX_VALUE; i++ ){ map.put(String.valueOf(i1), String.valueOf(i1)); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"休息1s之后，尝试获取第二把锁\"); } }).start(); } }public static void main(String[] args) { HashMap\u003cString, String\u003e map = new HashMap\u003c\u003e(); for(int i=0; i\u003c2; i++){ new Thread(() -\u003e { synchronized (lock1) { System.out.println(Thread.currentThread().getName() + \"获取了第一把锁\"); for(int i1 = 0; i1 \u003cInteger.MAX_VALUE; i1++ ){ map.put(String.valueOf(i1), String.valueOf(i1)); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"休息1s之后，尝试获取第二把锁\"); } }).start(); } } ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:1:2","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"3.避免死锁 3.1 预防死锁 核心思想是破坏死锁的四个必要条件之一 破坏互斥条件：破坏互斥条件而预防死锁不大可行，而且有的场合应该保持这种互斥性。 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源。 破坏请求保持条件：进程在运行前一次申请完它所需要的全部资源；在未满足全部资源时不运行。 破坏循环等待条件：给系统中的每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源， 释放则相反。 3.2 避免死锁 不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种 方法去防止系统进入不安全状态，从而避免死锁的产生。即：分配资源之前判断是否会出现死锁 若一个进程的请求会导致死锁，则不启动。 若一个进程的增加资源会导致死锁，则不启动。 常实现方法：银行家算法 银行家算法是操作系统中最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。 所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, …, Pn)，为每个进程Pi分配其所需资源， 直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, …, Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。（安全是指系统能找到一个序列 使得所有资源得到分配。） 如果系统处于安全状态，就一定不会发生死锁；如果系统处于不安全状态，就\"可能\"会发生死锁。 3.3 解除死锁 (1).终止进程 ①.终止所有死锁进程 这是最简单的方法，终止所有死锁进程后，死锁自然就解除了。 缺点： 代价可能会很大：有些快要结束的进程一旦被终止，可谓是“功亏一篑”。 ②.逐个终止进程，直至死锁解除 比上面的方法更温和一些，按照某种约定好的顺序，一个一个地终止进程，当有足够的资源时，就打破 了循环等待，死锁解除。 选择被终止的进程的策略：为死锁解除所付出的“代价最小”。“代价最小”应该考虑的一些因素： 1). 进程的优先级大小 2). 进程已经执行了多少时间？以后还需要多少时间才能完成？ 3). 进程已经使用了多少资源？以后还需要多少资源？ 缺点： 付出的代价也可能会很大，因为每终止一个进程，都要用死锁检测算法确定系统死锁是否已经被解除。 (2).超时放弃 当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式， 也可以很有效地避免死锁。 时序图如下： public static void main(String[] args) { /* * ReentrantLock（可重入锁）:提供了无条件的，可轮询的，定时的以及可中断的锁获取操作和解锁都是显式的 * */ Lock lock1 = new ReentrantLock(); Lock lock2 = new ReentrantLock(); Thread thread1 = new Thread(() -\u003e { lock1.lock(); //获取第一把锁 System.out.println(Thread.currentThread().getName() + \"获取了第一把锁\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(Thread.currentThread().getName() + \"休息1s之后，尝试获取第二把锁\"); try { if(lock2.tryLock(3000, TimeUnit.MILLISECONDS)){ System.out.println(Thread.currentThread().getName() + \"获取第二把锁\"); }else{ System.out.println(\"超过3s未获得第二把锁，线程1释放第一把锁\"); lock1.unlock(); } } catch (InterruptedException e) { e.printStackTrace(); } }); thread1.start(); Thread thread2 = new Thread(() -\u003e { lock2.lock(); //获取第二把锁 System.out.println(Thread.currentThread().getName() + \"获取了第二把锁\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"休息1s之后，尝试获取第一把锁\"); lock1.lock(); try { if(lock1.tryLock()){//获取第一把锁 System.out.println(Thread.currentThread().getName() + \"获取第一把锁\"); } } catch (Exception e) { e.printStackTrace(); }finally{ //使用lock时,一定记住在finally块中释放锁防止死锁的发生。 lock1.unlock(); //释放第一把锁 lock2.unlock(); //释放第二把锁 } }); thread2.start(); } synchronized与lock区别： 1）Lock是一个接口，而synchronized是Java中的关键字; 2）synchronized当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，不能够响应中断,（释放条件：1.执行完线程自动释放；2.发生异常jvm让线程释放）。 3）Lock锁，可以不让等待的线程一直无期限地等待下去，比如只等待一定的时间或者响应中断。 但Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock时必须在try{}catch{}块中进行，需要在finally块中释放锁； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即 有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据 适当情况选择。 (3).资源抢占的方法 通过打破循环等待条件与请求并持有条件来解决死锁问题。 ①.顺序锁 所谓顺序锁就是有顺序的获取锁，从而避免环路等待条件，解决死锁问题。 线程 1 先获取了锁 A，再获取锁 B，线程 2 与 线程 1 同时执行，线程 2 先获取锁 B，再获取锁 A，这样双方都先占用了各自的资源（锁 A 和锁 B）之后，再尝试获取对方的锁，从而造成了环路等待问题，最后造成了死锁的问题。 此时我们只需要将线程 1 和线程 2 获取锁的顺序进行统一，也就是线程 1 和线程 2 同时执行之后，都先获取锁 A，再获取锁 B，执行流程如下图所示： 因为只有一个线程能成功获取到锁 A，没有获取到锁 A 的线程就会等待先获取锁 A，此时得到锁 A 的线程继续获取锁 B，因为没有线程争抢和拥有锁 B，那么得到锁 A 的线程就会顺利的拥有锁 B，之后执行相应的代码再将锁资源全部释放，然后另一个等待获取锁 A 的线程就可以成功获取到锁资源，执行后续的代码，这样就不会出现死锁的问题了。 public class SolveDeadLockExample { public static void main(String[] args) { Object lockA = new Object(); // 创建锁 A Object lockB = new Object(); // 创建锁 B // 创建线程 1 Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (lockA) { System.out.println(\"线程 1:获取到锁 A!\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程 1:等待获取 B...\"); synchronized (lockB) { System.out.println(\"线程 1:获取到锁 B!\"); } } } }); t1.start(); // 运行线程 // 创建线程 2 Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:1:3","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"4.Jconsole查看死锁 进入java安装的位置，输入Jconsole，然后弹出界面（或者进入安装目录/java/jdk1.70_80/bin/，点击 Jconsole.exe）： 选中进程点击连接 点击线程选中检测死锁 Thread-0需要Thread-1持有的对象，Thread-1需要Thread-0持有的对象，然后陷入等待。 ","date":"2022-09-05","objectID":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/:1:4","tags":["Java","JVM","JUC"],"title":"JVM内存模型和死锁","uri":"/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%AD%BB%E9%94%81/"},{"categories":["Java"],"content":"了解java.time包","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"java.time 包是在JDK8新引入的，提供了用于日期、时间和实例的主要API。使用instants, durations, dates, times, time-zones 等类定义的工厂方法。Date-Time API中的所有类均生成不可变的实例，所有实例都是不可变的 Java 8 之 java.time 包 ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:0:0","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"概述 java.time 包是在JDK8新引入的，提供了用于日期、时间和实例的主要API。使用instants, durations, dates, times, time-zones 等类定义的工厂方法。Date-Time API中的所有类均生成不可变的实例，所有实例都是不可变的。由于这些类不提供公共构造函数，需要采用工厂方法加以实例化。（of,now两种静态工厂方法） ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:0:1","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"一些类的介绍 LocalDateTime:存储了日期和时间，如：2013-10-15T14:43:14.539。 LocalDate:存储了日期，如：2013-10-15。 LocalTime:存储了时间，如：14:43:14.539。 Instant类 Instant类对时间轴上的单一瞬时点建模，可以用于记录应用程序中的事件时间戳 Duration类 Duration类表示秒或纳秒时间间隔，适合处理较短的时间，需要更高的精确性。 Period类 Period类表示一段时间的年、月、日。 ZonedDateTime类 ZonedDateTime是具有时区的日期时间的不可变表示，此类存储所有日期和时间字段，精度为纳秒，时区为区域偏移量，用于处理本地日期时间。 上面的类可以由下面的类组合来： Year：表示年份。 Month：表示月份。 YearMonth：表示年月。 MonthDay：表示月日。 DayOfWeek：存储星期的一天。 用now创建实例 import java.time.*; public class One { public static void main(String[] args) { System.out.println(\"Instant.now()\"+ Instant.now()); System.out.println(\"LocalDate.now()\"+ LocalDate.now()); System.out.println(\"LocalTime.now()\"+ LocalTime.now()); System.out.println(\"LocalDateTime.now()\"+ LocalDateTime.now()); System.out.println(\"ZonedDateTime.now()\"+ ZonedDateTime.now()); } } 结果是： Instant.now()2022-10-03T06:36:24.599Z LocalDate.now()2022-10-03 LocalTime.now()14:36:24.662 LocalDateTime.now()2022-10-03T14:36:24.662 ZonedDateTime.now()2022-10-03T14:36:24.662+08:00[Asia/Shanghai] 在英国伦敦（Europe/London）它的偏移量是Z，代表+00:00偏移量，属于0时区、0偏移量地区，格林威治是世界的“时间中心”。格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：GreenwichMeanTime，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治时）的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能和实际的太阳时相差16分钟。地球每天的自转是有些不规则的，而且正在缓慢减速。所以，格林尼治时间已经不再被作为标准时间使用。用标准时间──协调世界时（UTC）──由原子钟来代替。 下面列出世界主要城市时区ID对应的UTC偏移量： 时区ID UTC偏移 Asia/Shanghai +08:00 Asia/Chongqing +08:00 America/New_York -05:00 Europe/London Z Europe/Paris +01:00 Europe/Moscow +03:00 Asia/Tokyo +09:00 Asia/Dubai +04:00 Asia/Seoul +09:00 Asia/Bangkok +07:00 Asia/Jakarta +07:00 上面的例子所有输出值均使用ISO 8601标准格式。日期的基本格式为yyyy-MM-dd，而时间的基本格式为hh:mm:ss.sss。LocalDateTime类将两种格式合并，中间用大写字母T隔开。ZonedDateTime类用于显示包含时区信息的日期和时间，在后面添加了一个UTC偏移量以及地区名。Instant类定义的toString方法将输出以祖鲁时间（Zulu time）显示的当前时间。 静态方法of用于生成新的值。对于LocalDate类而言，of方法的参数为年、月（枚举或整形）、日。of方法可以根据给定的参数生成对应的日期/时间对象，基本上每个基本类都有of方法用于生成的对应的对象。 给你提供了静态的构造方法，不能new,它们都是private import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.Month; public class Armstrong { public static void main(String[] args) { System.out.println(\"First landing on the Moon:\"); LocalDate moonLandingDate=LocalDate.of(1969, Month.JULY,20); LocalTime moonLandingTime= LocalTime.of(20,18); System.out.println(\"Date:\"+moonLandingDate); System.out.println(\"Time:\"+moonLandingTime); System.out.println(\"Neil Armstrong steps onto the surface:\"); LocalTime walkTime=LocalTime.of(20,2,56,150_000_000); LocalDateTime walk=LocalDateTime.of(moonLandingDate,walkTime); System.out.println(walk); } } 结果是： First landing on the Moon: Date:1969-07-20 Time:20:18 Neil Armstrong steps onto the surface: 1969-07-20T20:02:56.150 ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:0:2","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"方法概览 Date-Time包中的API提供了大量相关的方法，这些方法一般有一致的方法前缀： 静态工厂： of：静态工厂方法。创建实例 parse：静态工厂方法，解析输入字符串。 实例： format: 实例。生成格式化输出。 get：返回对象状态的一部分。 is：查询对象状态。 with：通过修改现有对象的某个元素来创建新对象。 plus：加一些量到某个对象来创建新对象。 minus：从某个对象减去一些量来创建新对象。 at：将对象与另一个对象组合起来，例如：date.atTime(time)。 例子：用at方法为本地日期和时间添加时区。 import java.time.LocalDateTime; import java.time.Month; import java.time.ZoneId; import java.time.ZonedDateTime; public class eightfour { public static void main(String[] args) { LocalDateTime dateTime= LocalDateTime.of(2017, Month.JULY,4,13,20,10); ZonedDateTime nyc=dateTime.atZone(ZoneId.of(\"America/New_York\")); System.out.println(nyc); ZonedDateTime london=nyc.withZoneSameInstant(ZoneId.of(\"Europe/London\"));//**withZoneSameInstant方法传入一个ZonedId,并查找另一个时区的日期和时间。** System.out.println(london); } } 结果为： 2017-07-04T13:20:10-04:00[America/New_York] 2017-07-04T18:20:10+01:00[Europe/London] withZoneSameInstant方法传入一个ZonedId,并查找另一个时区的日期和时间。 toEpochSecond() 方法用于将此 LocalTime 转换为自 1970-01-01T00:00:00Z 纪元以来的秒数。该方法将此本地时间与作为参数传递的指定日期和偏移量相结合，以计算纪元秒值，即从 1970-01-01T00:00:00Z 开始经过的秒数。纪元之后时间轴上的瞬间为正，更早为负。另外，java-time包中引入了Month和DayOfWeek两种枚举。Month包括标准日历中12个月份的常量（从JANUARY到DECEMBER） DayOfWeek枚举包括7个工作日的常量（从Monday到Sunday） import java.time.DayOfWeek; import java.time.Month; import java.time.MonthDay; public class monthenum { public static void main(String[] args) { System.out.println(\"Days in Feb in a leap year:\"+ Month.FEBRUARY.length(true)); System.out.println(\"Days of year for first day of Aug(leap year):\"+Month.AUGUST.firstDayOfYear(true)); System.out.println(\"Month.of(1):\"+Month.of(1)); System.out.println(\"dayofweek\"+ DayOfWeek.of(7)); System.out.println(\"Adding two months:\"+Month.JANUARY.plus(2)); System.out.println(\"Subtracting a month:\"+Month.MARCH.minus(1)); } } 结果为： Days in Feb in a leap year:29 Days of year for first day of Aug(leap year):214 Month.of(1):JANUARY dayofweekSUNDAY Adding two months:MARCH Subtracting a month:FEBRUARY Process finished with exit code 0 java.time包中的类是不可变的，如果实例方法（如plus、minus或with）试图修改某个类，将生成一个新的实例。 ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:0:3","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"根据现有实例创建日期和时间 用户希望修改date-time API中的某个类现有实例 加减用plus或minus，其余用with 以LocalDate为例，它定义了多种对日期进行增减操作的方法，包括： LocalDate plusDay(long days) 增加天数 LocalDate plusWeeks(long weeks) 增加周数 LocalDate plusMonths(long months) 增加月数 LocalDate plusYears(long years) 增加年数 以上方法均返回一个新的localDate，它是当前日期的副本，并添加了指定的值 我们要进行格式化显示，就要使用DateTimeFormatter。DateTimeFormatter可以只创建一个实例，到处引用。 创建DateTimeFormatter时，我们仍然通过传入格式化字符串实现： DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss:sss\"); 另一种创建DateTimeFormatter的方法是，传入格式化字符串时，同时指定Locale： DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"E, yyyy-MMMM-dd HH:mm\", Locale.US); 这种方式可以按照Locale默认习惯格式化。我们来看实际效果： import java.time.*; import java.time.format.*; import java.util.Locale; public class Main { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(); var formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm ZZZZ\"); System.out.println(formatter.format(zdt)); var zhFormatter = DateTimeFormatter.ofPattern(\"yyyy MMM dd EE HH:mm\", Locale.CHINA); System.out.println(zhFormatter.format(zdt)); var usFormatter = DateTimeFormatter.ofPattern(\"E, MMMM/dd/yyyy HH:mm\", Locale.US); System.out.println(usFormatter.format(zdt)); } } 结果是： 2022-10-08T15:34 GMT+08:00 2022 十月 08 星期六 15:34 Sat, October/08/2022 15:34 在格式化字符串中，如果需要输出固定字符，可以用'zzz'表示。 当我们直接调用System.out.println()对一个ZonedDateTime或者LocalDateTime实例进行打印的时候，实际上，调用的是它们的toString()方法，默认的toString()方法显示的字符串就是按照ISO 8601格式显示的，我们可以通过DateTimeFormatter预定义的几个静态变量来引用： var ldt = LocalDateTime.now(); System.out.println(DateTimeFormatter.ISO_DATE.format(ldt)); System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt)); 得到的输出和toString()类似： 2019-09-15 2019-09-15T23:16:51.56217 ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:1:0","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"小结 对ZonedDateTime或LocalDateTime进行格式化，需要使用DateTimeFormatter类； DateTimeFormatter可以通过格式化字符串和Locale对日期和时间进行定制输出。 import org.junit.Test; import java.time.LocalDate; import java.time.LocalTime; import java.time.Month; import java.time.format.DateTimeFormatter; import static org.junit.Assert.assertEquals; public class eightsix { @Test public void localDatePlus() throws Exception{ DateTimeFormatter formatter=DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate start=LocalDate.of(2017, Month.FEBRUARY,2); LocalDate end=start.plusDays(3); assertEquals(\"2017-02-05\",end.format(formatter));//assertequals断言，去判断写入的值与它是否相等，相等则不报错。 System.out.println(end.format(formatter)); end=start.plusWeeks(5); assertEquals(\"2017-03-09\",end.format(formatter)); System.out.println(end.format(formatter)); end=start.plusMonths(7); assertEquals(\"2017-09-02\",end.format(formatter)); System.out.println(end.format(formatter)); end=start.plusYears(2); assertEquals(\"2019-02-02\",end.format(formatter)); System.out.println(end.format(formatter)); } @Test public void localTimePlus() throws Exception{ DateTimeFormatter formatter=DateTimeFormatter.ISO_LOCAL_TIME; LocalTime start=LocalTime.of(11,30,0,0); LocalTime end=start.plusNanos(1000000); assertEquals(\"11:30:00.001\",end.format(formatter)); System.out.println(end.format(formatter)); end=start.plusSeconds(20); assertEquals(\"11:30:20\",end.format(formatter)); System.out.println(end.format(formatter)); end=start.plusMinutes(45); assertEquals(\"12:15:00\",end.format(formatter)); System.out.println(end.format(formatter)); end=start.plusHours(5); assertEquals(\"16:30:00\",end.format(formatter)); System.out.println(end.format(formatter)); } } 结果是： 2017-02-05 2017-03-09 2017-09-02 2019-02-02 11:30:00.001 11:30:20 12:15:00 16:30:00 assertequals断言，去判断写入的值与它是否相等，相等则不报错。 with将时间修改成指定值。 每种类都定义了一系列with方法，可以一次修改一个字段。 with方法用于处理日期和时间并提供了很多种修改时间的方式 LocalDateTime withNano(int i) 修改纳秒 LocalDateTime withSecond(int i) 修改秒 LocalDateTime withMinute(int i) 修改分钟 LocalDateTime withHour(int i) 修改小时 LocalDateTime withDayOfMonth(int i) 修改日 LocalDateTime withMonth(int i) 修改月 LocalDateTime withYear(int i) 修改年 import org.junit.Test; import java.time.DateTimeException; import java.time.LocalDateTime; import java.time.Month; import java.time.format.DateTimeFormatter; import static org.junit.Assert.assertEquals; public class eighteight { @Test public void with() throws Exception{ LocalDateTime start=LocalDateTime.of(2017, Month.FEBRUARY,2,11,30); LocalDateTime end=start.withMinute(45); assertEquals(\"2017-02-02T11:45:00\",end.format(DateTimeFormatter.ISO_DATE_TIME)); System.out.println(end.format(DateTimeFormatter.ISO_DATE_TIME)); end=start.withHour(16); assertEquals(\"2017-02-02T16:30:00\",end.format(DateTimeFormatter.ISO_DATE_TIME)); System.out.println(end.format(DateTimeFormatter.ISO_DATE_TIME)); end=start.withDayOfMonth(28); assertEquals(\"2017-02-28T11:30:00\",end.format(DateTimeFormatter.ISO_DATE_TIME)); System.out.println(end.format(DateTimeFormatter.ISO_DATE_TIME)); end=start.withDayOfYear(300); assertEquals(\"2017-10-27T11:30:00\",end.format(DateTimeFormatter.ISO_DATE_TIME)); System.out.println(end.format(DateTimeFormatter.ISO_DATE_TIME)); end=start.withYear(2020); assertEquals(\"2020-02-02T11:30:00\",end.format(DateTimeFormatter.ISO_DATE_TIME)); System.out.println(end.format(DateTimeFormatter.ISO_DATE_TIME)); } @Test()//在括号里写expected=DateTimeException.class,很意外 public void withInvalidDate() throws Exception{ LocalDateTime start=LocalDateTime.of(2017,Month.FEBRUARY,2,11,30); start.withDayOfMonth(29); } } 结果是： 2017-02-02T11:45:00 2017-02-02T16:30:00 2017-02-28T11:30:00 2017-10-27T11:30:00 2020-02-02T11:30:00 java.time.DateTimeException: Invalid date 'February 29' as '2017' is not a leap year at java.time.LocalDate.create(LocalDate.java:429) at java.time.LocalDate.of(LocalDate.java:269) at java.time.LocalDate.withDayOfMonth(LocalDate.java:1099) at java.time.LocalDateTime.withDayOfMonth(LocalDateTime.java:1023) at eighteight.withInvalidDate(eighteight.java:38) at s","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:1:1","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"调节器与查询 给定时态值，用户希望自定义调整，或检索给定值的有关信息。 解决方式：创建TemporalAdjuster或规划TemporalQuery接口。 1.TemporalAdjuster接口定义了一个名为adjustInto的方法，它传入的Temporal值作为参数，并返回调整后的值。而TemporalAdjusters类包括一系列用作静态方法的调节器（adjuster） static TemporalAdjuster firstDayOfNextMonth() static TemporalAdjuster firstDayOfNextYear() static TemporalAdjuster firstDayOfYear() static TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)等 TemporalAdjusters类定义的部分静态方法 import org.junit.Test; import java.time.DayOfWeek; import java.time.LocalDateTime; import java.time.Month; import java.time.temporal.TemporalAdjuster; import java.time.temporal.TemporalAdjusters; import static org.junit.Assert.assertEquals; public class eightten { @Test public void adjusters() throws Exception{ LocalDateTime start=LocalDateTime.of(2017, Month.FEBRUARY,2,11,30); LocalDateTime end=start.with(TemporalAdjusters.firstDayOfNextMonth()); assertEquals(\"2017-03-01T11:30\",end.toString()); System.out.println(end); end=start.with(TemporalAdjusters.next(DayOfWeek.THURSDAY));//TemporalAdjusters类的next (DayOfWeek)方法用于返回下一个day-of-week TemporalAdjuster对象，该对象可用于获取新的Date对象，该对象是具有相同匹配DayOfWeek的下一个日期，该日期作为参数从任何Date对象上传递将应用此TempotralAdjuster。 assertEquals(\"2017-02-09T11:30\",end.toString()); System.out.println(end); end=start.with(TemporalAdjusters.previousOrSame(DayOfWeek.THURSDAY));//TemporalAdjusters类的previousOrSame (DayOfWeek)方法用于返回先前或相同的day-of-week TemporalAdjuster对象，该对象可用于获取新的Date对象，该对象是先前或相同日期的具有相同匹配的day-of-week作为参数从任何对象传递应用此TempotralAdjuster的Date对象。 assertEquals(\"2017-02-02T11:30\",end.toString()); System.out.println(end); } } 结果为： 2017-03-01T11:30 2017-02-09T11:30 2017-02-02T11:30 应用：假设员工在一个月中领取两次工资，且发薪日是每月15日和最后一天；如果某个发薪日为周末，则提前到周五。 import org.junit.Test; import java.time.DayOfWeek; import java.time.LocalDate; import java.time.Month; import java.time.temporal.Temporal; import java.time.temporal.TemporalAdjuster; import java.time.temporal.TemporalAdjusters; import java.util.stream.IntStream; import static org.junit.Assert.assertEquals; public class PayDayAdjuster implements TemporalAdjuster { public Temporal adjustInto(Temporal input){//adjustInto方法已被添加到实现TemporalAdjuster接口的PaydayAdjuster类中 LocalDate date= LocalDate.from(input);//from方法可以将任何时态对象转换为LocalDate int day; if(date.getDayOfMonth()\u003c15){ day=15; }else{ day=date.with(TemporalAdjusters.lastDayOfMonth()) .getDayOfMonth(); } date=date.withDayOfMonth(day); if(date.getDayOfWeek()== DayOfWeek.SATURDAY|| date.getDayOfWeek()==DayOfWeek.SUNDAY){ date=date.with(TemporalAdjusters.previous(DayOfWeek.FRIDAY)); } return input.with(date); } @Test public void payDay() throws Exception{ TemporalAdjuster adjuster=new PayDayAdjuster(); IntStream.rangeClosed(1,14) .mapToObj(day-\u003eLocalDate.of(2017, Month.JULY,day)) .forEach(date-\u003e assertEquals(14,date.with(adjuster).getDayOfMonth())); IntStream.rangeClosed(15,31) .mapToObj(day-\u003eLocalDate.of(2017,Month.JULY,day)) .forEach(date-\u003e assertEquals(31,date.with(adjuster).getDayOfMonth())); } } 时态类对象（LocalDate类，LocalTime类）都有一个方法叫做query()，可以针对日期进行查询，R query(TemporalQuery query)这个方法是一个泛型方法，返回的数据就是传入的泛型类的类型，TemporalQuery是一个泛型接口，里面有一个抽象方法是R queryFrom(TemporalAccessor temporal)，TemporalAccessor是Temporal的父接口，实际上也就是LocalDate,LocalDateTime相关类的顶级父接口，这个**queryFrom()**的实现逻辑就是，传入一个日期/时间对象通过自定义逻辑返回数据。 如果要计划日期距离某一天特定天数差距多少天，可以自定义类实现TemporalQuery接口并且作为参数传到query方法中。 TemporalQuery的应用 TemporalQuery接口用作时态对象中query方法的参数。query方法调用TemporalQuery.queryFrom(TemporalAccessor)方法（传入this作为参数），并返回所需要的查询。TemporalAccessor接口定义的所有方法均可用于查询操作。Date-Time API还包括一个名为TemporalQueries的类，它定义了许多常见查询的常量： static TemporalQuery localDate() static TemporalQuery localTime() static TemporalQuery zone() static TemporalQuery zoneId() //计算当前时间距离下一个劳动节还有多少天？ import org.junit.Test; import java.time.LocalDate; import java.time.Month; import java.time.temporal.ChronoUnit; import java.time.temporal.TemporalAccessor; import java.time.temporal.TemporalQuery; public class UtilDayQueryImpl implements TemporalQuery\u003cLong\u003e { @Override public Long queryFrom(TemporalAccessor temporalAccessor) { // 1. TemporalAccess","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:2:0","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"解析与格式化 DateTimeFormatter类用于创建日期/时间格式，可以在解析和格式化中使用。 ChronoUnit：计算出两个时间点之间的时间距离，可按多种时间单位计算。 TemporalAdjuster：各种日期计算功能。 DateTimeFormatter类提供大量预定义格式化器，包括常量（ISO_LOCAL_DATE)、模式字母（如uuuu-MMM-dd）以及本地化样式（ofLocalizedDate（dateStyle）） 在Date-time API中，所有的类均提供parse和format方法。 //对日期进行格式化 import java.sql.SQLOutput; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.Month; import java.time.format.DateTimeFormatter; import java.time.format.FormatStyle; import java.util.Locale; public class eightthirty { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); String text = now.format(DateTimeFormatter.ISO_DATE_TIME);//将LocalDateTime格式化为字符串 LocalDateTime dateTime = LocalDateTime.parse(text);//将字符串解析为LocalDateTime LocalDate date = LocalDate.of(2017, Month.MARCH, 13); System.out.println(\"Full:\" + date.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL))); System.out.println(\"long:\" + date.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG))); System.out.println(\"Medium:\" + date.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM))); System.out.println(\"Short:\" + date.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT))); System.out.println(\"France:\" + date.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).withLocale(Locale.FRANCE))); Locale loc = new Locale.Builder().setLanguage(\"sr\").setScript(\"Latn\").setRegion(\"RS\").build(); //setScript设置脚本 System.out.println(\"Serbian\"+date.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).withLocale(loc))); } } 结果是： Full:2017年3月13日 星期一 long:2017年3月13日 Medium:2017-3-13 Short:17-3-13 France:lundi 13 mars 2017 Serbianponedeljak, 13. mart 2017. 查找具有非整数小时偏移量的时区 大部分时区的UTC偏移量均为小时的整数，当然有些地区也存在UTC偏移量为半小时甚至四十五分钟的时区，该如何解决？ 方案：获取每个时区的地区偏移量，并计算总秒数除以3600之后的剩余时间。通过ZoneOffset类查找每个时区ID相对于UTC的偏移量，并将其与3600秒（1小时）进行比较。 import java.time.Instant; import java.time.ZoneId; import java.time.ZoneOffset; import java.time.ZonedDateTime; import java.time.format.DateTimeFormatter; import java.time.format.FormatStyle; import static java.util.Comparator.comparingInt; public class FunnyOffsets { public static void main(String[] args) { Instant instant= Instant.now(); ZonedDateTime current=instant.atZone(ZoneId.systemDefault()); System.out.printf(\"Current time is %s%n%n\",current); System.out.printf(\"%10s %20s %13s%n\",\"Offset\",\"ZoneId\",\"Time\"); ZoneId.getAvailableZoneIds().stream() .map(ZoneId::of)//将地区ID映射到时区ID .filter(zoneId -\u003e { ZoneOffset offset=instant.atZone(zoneId).getOffset();//计算偏移量 return offset.getTotalSeconds()%(60*60)!=0;//仅返回偏移量无法被3600整除的时区 }) .sorted(comparingInt(zoneId -\u003e instant.atZone(zoneId).getOffset().getTotalSeconds()))//按照offset偏移量排序 .forEach(zoneId -\u003e { ZonedDateTime zdt=current.withZoneSameInstant(zoneId); System.out.printf(\"%10s %25s %10s%n\", zdt.getOffset(),zoneId, zdt.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT)));//ofLocalizedTime和本地时间比较 }); } } 结果为： Current time is 2022-10-04T19:32:12.447+08:00[Asia/Shanghai] Offset ZoneId Time -09:30 Pacific/Marquesas 上午2:02 -02:30 America/St_Johns 上午9:02 -02:30 Canada/Newfoundland 上午9:02 +03:30 Iran 下午3:02 +03:30 Asia/Tehran 下午3:02 +04:30 Asia/Kabul 下午4:02 +05:30 Asia/Kolkata 下午5:02 +05:30 Asia/Colombo 下午5:02 +05:30 Asia/Calcutta 下午5:02 +05:45 Asia/Kathmandu 下午5:17 +05:45 Asia/Katmandu 下午5:17 +06:30 Asia/Yangon 下午6:02 +06:30 Asia/Rangoon 下午6:02 +06:30 Indian/Cocos 下午6:02 +08:30 Asia/Pyongyang 下午8:02 +08:45 Australia/Eucla 下午8:17 +09:30 Australia/North 下午9:02 +09:30 Australia/Darwin 下午9:02 +10:30 Australia/Yancowinna 下午10:02 +10:30 Australia/Adelaide 下午10:02 +10:30 Australia/Broken_Hill 下午10:02 +10:30 Australia/South 下午10:02 +13:45 NZ-CHAT 上午1:17 +13:45 Pacific/Chatham 上午1:17 ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:3:0","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"获取事件之间的时间 将时间转换成人们可读的格式，使用时态类（temporal class）定义的between或until方法，或period类定义的between方法以生成period对象，若不需要转换时间格式，则使用以秒和纳秒为单位对时间量进行建模的duration类。在java.time.temporal包中，TempoalUnit接口由定义在同一个包中的ChronoUnit枚举实现。TemporalUnit接口定义了一个名为between的方法，它传入两个TemporalUnit实例并返回二者之间的时间量（long型数据）。 计算当天到美国选举日之间的天数 import java.time.LocalDate; import java.time.Month; import java.time.temporal.ChronoUnit; public class USchairman { public static void main(String[] args) { LocalDate electionary=LocalDate.of(2022, Month.NOVEMBER,3); LocalDate today=LocalDate.now(); System.out.printf(\"%d day(s) to go ...%n\", ChronoUnit.DAYS.between(today,electionary)); } } 结果是： 31 day(s) to go... 用period类计算时间差 主要是Period类方法getYears（），getMonths（）和getDays（）来计算. import java.time.LocalDate; import java.time.Month; import java.time.Period; public class TestPeriod { public static void main(String[] args) { LocalDate today = LocalDate.now(); System.out.println(\"Today : \" + today); LocalDate birthDate = LocalDate.of(1993, Month.OCTOBER, 19); System.out.println(\"BirthDate : \" + birthDate); Period p = Period.between(birthDate, today); System.out.printf(\"年龄 : %d 年 %d 月 %d 日\", p.getYears(), p.getMonths(), p.getDays()); } } 结果是： Today : 2022-10-08 BirthDate : 1993-10-19 年龄 : 28 年 11 月 19 日 ","date":"2022-08-05","objectID":"/java%E4%B9%8Btime%E5%8C%85/:4:0","tags":["Java"],"title":"java.time包","uri":"/java%E4%B9%8Btime%E5%8C%85/"},{"categories":["Java"],"content":"了解Java注解和反射.","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种机制。Java 语言中的类、方法、变量、参数和包等都可以被标注…. 注解 Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。 ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:0:0","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"1.Annotation定义 例如我们得@Override注解，其定义方式为： import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 可以看到Override这个注解上还加了@Target和@Retention注解，我们称它们为元注解。进入Target其中： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Target { /** * Returns an array of the kinds of elements an annotation interface * can be applied to. */ ElementType[] value(); } 即在其中可以定义方法。其格式为，例：String name（）； 自己定义一个注解 public @interface myAnnotation { Stirng name(); } //在其他类、方法、变量、参数上使用只需 @myAnnotation(name = \"张三\") public xx (){} 上述注解中定义了一个name方法，所以在注解应用过程中必须给他赋值。定义方法的注意事项： 1、定义的格式是：String name(); 2、可以有默认值，也可以没有，如果没有默认值在使用的时候必须填写对应的值。默认值使用default添加。例如 Stirng name() default “张三”; 3、如果想在使用的时候不指定具体的名字，方法名字定义为value() 即可。（只能定义一个，即使用时直接写xx不用写name = xx） ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:1:0","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"1.Annotation相关组成 //我们发现字节码中注解其实也是一个接口统一继承自java.lang.annotation.Annotation package java.lang.annotation; public interface Annotation { boolean equals(Object obj); int hashCode(); String toString(); Class\u003c? extends Annotation\u003e annotationType(); } 这个java.lang.annotation包下和我们元注解有关的类： 1.ElementType ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。大白话就是，说明了我的注解将来要放在哪里。 public enum ElementType { // 类、接口（包括注释类型）或枚举声明 TYPE, // 字段声明（包括枚举常量 FIELD, // 方法声明 METHOD, // 参数声明 PARAMETER, // 构造方法声明 CONSTRUCTOR, // 局部变量声明 LOCAL_VARIABLE, // 注释类型声明 ANNOTATION_TYPE, // 包声明 PACKAGE } 例如我们在Override中元注解@Target(ElementType.METHOD)，代表此注解只能加在方法上。（可以用逗号同时写多个地方） 2.RetentionPolicy.java RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，\" @Override\" 标志就是一个 SOURCE。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，\"@Override\" 就没有任何作用了。 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。 package java.lang.annotation; public enum RetentionPolicy { //Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 SOURCE, //编译器将Annotation存储于类对应的.class文件中。但不会加载到JVM中。默认行为 CLASS, // 编译器将Annotation存储于class文件中，并且可由JVM读入，因此运行时我们可以获取。 RUNTIME } ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:2:0","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"3.自带的 Annotation #（1）内置的注解 Java 定义了一套注解，共有10 个，6个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 （1）作用在代码的注解是 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 （2）作用在其他注解的注解(或者说 元注解)是: @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解可以修饰哪些 Java 成员。 @Inherited - 如果一个类用上了@Inherited修饰的注解，那么其子类也会继承这个注解 #（2）常用注解 通过上面的示例，我们能理解：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型，@Retention 用来指定 Annotation 的策略。 @Documented 标记这些注解是否包含在用户文档中。 @Inherited @Inherited 的定义如下：加有该注解的注解会被子类继承，注意，仅针对类，成员属性、方法并不受此注释的影响。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Inherited { } @SuppressWarnings @SuppressWarnings 的定义如下： @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } SuppressWarnings 的作用是，让编译器对\"它所标注的内容\"的某些警告保持静默，用于抑制编译器产生警告信息。。例如，\"@SuppressWarnings(value={“deprecation”, “unchecked”})\" 表示对\"它所标注的内容\"中的 “SuppressWarnings 不再建议使用警告\"和\"未检查的转换时的警告\"保持沉默。 关键字 用途 all 抑制所有警告 boxing 抑制装箱、拆箱操作时候的警告 fallthrough 抑制在switch中缺失breaks的警告 finally 抑制finally模块没有返回的警告 rawtypes 使用generics时忽略没有指定相应的类型 serial 忽略在serializable类中没有声明serialVersionUID变量 unchecked 抑制没有进行类型检查操作的警告 unused 抑制没被使用过的代码的警告 ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:3:0","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"Annotation 的作用 （1）Annotation 具有\"让编译器进行编译检查的作用“。 （2）利用反射，和反射配合使用能产生奇妙的化学反应。 反射 在方法区存在这么一些对象，叫做类对象，他们表述了我们写的所有的类，当我们new对象时会根据这类对象，并调用其构造方法为我们创建实例。 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制。 功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法；生成动态代理 ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:4:0","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"反射API Java反射所需要的类并不多，主要有java.lang.Class类和java.lang.reflect包中的Field、Constructor、 Method、Annotation类。 每个类【有且仅有】一个Class类，也叫类对象。 Class类是Java反射的起源，我们只有先获得一个类对象才能进行后续操作。 ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:5:0","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"1.获取类对象方法 1、使用类 Class clazz = Dog.class; //用的少，没有体现反射的动态性，在编译期就会 2、使用全类名 Class aClass = Class.forName(\"com.xinzhi.Day\"); //体现反射的动态性/编译时看是不是一个字符串，是，编译通过，运行时就可以动态生成对象 3、使用对象 Dog dog = new Dog(); Class clazz = dog.getClass(); //com.xx.xx.Dog@.. 4.使用类加载器：ClassLoader ClassLoader classLoader = Test.class.getClassLoader(); Class clazz = classLoader.loadClass(\"com.lu.Dog\"); Class实例对应着加载到内存中的一个运行时类（经过编译后加载到内存中的类称为运行时类） ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:5:1","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"2.对类对象的一些操作 //获取类名字 String name = clazz.getName(); //获取类加载器 ClassLoader classLoader = clazz.getClassLoader(); //获取资源 URL resource = clazz.getResource(\"\"); //得到父类 Class superclass = clazz.getSuperclass(); //判断一个类是不是接口，数组等等 boolean array = clazz.isArray(); boolean anInterface = clazz.isInterface(); //重点，使用class对象实例化一个对象 Object instance = clazz.newInstance();//必须要有空参构造器，权限修饰符的权限要够。 ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:5:2","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"3、获取相关属性并操作 字段 Field 1.获取成员变量 //获取字段，只能获取公共的字段（public） Field name = clazz.getField(\"color\"); //打印结果public java.lang.String com.lu.cglib.Dog.color Field[] fields = clazz.getFields(); //获取所有字段， //能获取所有的字段包括private Field color = clazz.getDeclaredField(\"color\"); Field[] fields = clazz.getDeclaredFields(); System.out.println(color.getType()); 2.获取属性 Dog dog = new Dog(); dog.setColor(\"red\"); Class clazz = Dog.class; Field color = clazz.getDeclaredField(\"color\"); System.out.println(color.get(dog)); //当然你要是明确类型你还能用以下方法： Int i = age.getInt(dog); xxx.getDouble(dog); xxx.getFloat(dog); xxx.getBoolean(dog); xxx.getChar(dog); //每一种基本类型都有对应方法 3.获取方法 Dog dog = new Dog(); dog.setColor(\"red\"); Class clazz = Dog.class; //获取某个方法，第一个参数是方法名字，后边是参数类型， Method method = clazz.getMethod(\"eat\",String.class); //拿到参数的个数 int parameterCount = method.getParameterCount(); //拿到方法的名字 String name = method.getName(); //拿到参数的类型数组 Class\u003c?\u003e[] parameterTypes = method.getParameterTypes(); //拿到返回值类型 Class\u003c?\u003e returnType = method.getReturnType(); //重点。反射调用方法，传一个实例，和参数 method.invoke(dog,\"热狗\"); 一般调用invoke之前会有method.setAccessible(true)//保证当前的方法是可访问的。 //如何调用静态方法 Method method = clazz.getMethod(\"staticmethodName\"); method.setAccessible(true) Object returnVal = method.invoke(Dog.class);//参数里的DOg.class应该也不用写本来这个class实例就是通过这个类.出来的。而且静态方法也不需要对象。 4.构造函数 （1）获取并构建对象 Constructor[] constructors = clazz.getConstructors(); Constructor constructor = clazz.getConstructor(); Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); Constructor declaredConstructor = clazz.getDeclaredConstructor(); Object obj = constructor.newInstance(); /*Class.newInstance() 只能够调用无参的构造函数，即默认的构造函数； Constructor.newInstance() 可以根据传入的参数，调用任意构造构造函数。 Class.newInstance() 抛出所有由被调用构造函数抛出的异常。 Class.newInstance() 要求被调用的构造函数是可见的，也即必须是public类型的; Constructor.newInstance() 在特定的情况下，可以调用私有的构造函数。 5.注解 从方法、字段、类上获取注解 //元注解 要加上runtime //类上 Annotation annotation = clazz.getAnnotation(Bean.class); Annotation[] annotations = clazz.getAnnotations(); //字段上 Annotation annotation = field.getAnnotation(Bean.class); Annotation[] annotations = field.getAnnotations(); //方法上 Annotation annotation = method.getAnnotation(Bean.class); Annotation[] annotations = method.getAnnotations(); ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:5:3","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"加载配置文件 //加载在当前module配置文件的两种方式：` Properties pros = new Properties ();` //读取方式之一：` FileInputStream fis = new FileInputStream(\"jdbc.properties\");` pros.load(fis)` //2.使用ClassLoader,如配置文件在当前moudle的src下` ClassLoader classloader = Test.class.getClassLoader();` InputStream is = classloader.getResourceAsSteram(\"jdbc.properties\");` pros.load(is); String user = pros.getProperty(\"user\") ","date":"2022-07-05","objectID":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/:5:4","tags":["Java"],"title":"Java注解和反射","uri":"/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"了解Java枚举.","date":"2022-06-05","objectID":"/java%E6%9E%9A%E4%B8%BE/","tags":["Java"],"title":"Java枚举","uri":"/java%E6%9E%9A%E4%B8%BE/"},{"categories":["Java"],"content":"枚举类型（enum type）是指由一组常量组成合法值的类型… ","date":"2022-06-05","objectID":"/java%E6%9E%9A%E4%B8%BE/:0:0","tags":["Java"],"title":"Java枚举","uri":"/java%E6%9E%9A%E4%B8%BE/"},{"categories":["Java"],"content":"Java枚举 枚举类型（enum type）是指由一组常量组成合法值的类型； java枚举与其它语言的枚举不同，是Java语言的一个特性和优势； 何时使用枚举： 每当需要一组固定常量，并且在编译时就知道其成员的时候，就应该使用枚举！ ","date":"2022-06-05","objectID":"/java%E6%9E%9A%E4%B8%BE/:1:0","tags":["Java"],"title":"Java枚举","uri":"/java%E6%9E%9A%E4%B8%BE/"},{"categories":["Java"],"content":"枚举模式（enum pattern） //The int enum pattern public static final int APPLE = 0; public static final int BANANA = 1; public static final int PEAR = 2; public static final int PEACH = 3; public static final int ORANGE = 4; 其值可以在任一需要的地方调用！ 也可以通过反射获取其变量名称 System.out.println(EnumPatternDemo.APPLE); System.out.println(EnumPatternDemo.BANANA); for (Field field : EnumPatternDemo.class.getDeclaredFields()) System.out.println(field.getName() + field); 也通过反射可以获取其全部值： for (Field field : EnumPatternDemo.class.getDeclaredFields()) { try { System.out.println(field.getName() + \"-\"+field.getInt(field)); } catch (IllegalAccessException e) { e.printStackTrace(); } } 这种模式没有描述性；（譬如apple中的特性完全没有，想给apple赋予某种属性无法办到，想打印一个字符串也不行！） 不具有类型安全性；(譬如你将apple传到需要orange的方法中，是不会报错的，不好纠错！) 如果与apple相关联的值发生变化，必须重新编译； 把以上的int改成String也不会解决这些问题； 于是Java对枚举做了很大的扩展！ 成为Java的特色和优势之一！ ","date":"2022-06-05","objectID":"/java%E6%9E%9A%E4%B8%BE/:1:1","tags":["Java"],"title":"Java枚举","uri":"/java%E6%9E%9A%E4%B8%BE/"},{"categories":["Java"],"content":"枚举类型（enum type） //enum type public enum Fruits{APPLE,BANANA,PEAR,PEACH,ORANGE} Java的枚举类型是功能十分齐全的类！ 其功能比其它语言的对应的类强大得多！ Java枚举类型允许添加任意的方法和属性！ Java枚举类型允许实现任意接口！ 提供了Object所有方法的实现 实现了Comparable和serializable接口 Java枚举类型基本思想： 通过共有的静态final属性为每个枚举常量导出一个实例！ 枚举类型没有可访问的构造器！是真正的final类！ 客户端不能创建枚举实例，也不能对它进行扩展，所以不存在任何客户端实例（–不能多态、继承）！ 只存在声明了的常量实例–枚举常量！ 枚举类型保证了编译时的安全！！譬如fruits, 它保证了在引用fruit的地方，只能传递以上五个常量实例之一，其它任何值都非法！—编译时会报错！ 可以通过向枚举类型添加方法或属性，将数据与常量关联起来： //enum type public enum Fruits{ APPLE, BANANA, PEAR, PEACH, ORANGE private final String color; private final String smell; private final String taste; //constructor Fruit(String color,String smell,String taste){ this.color = color; this.smell = smell; this.taste = taste; } } 带有构造参数的枚举： import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @description: Todo * @author: ZZS * @date: 2022/9/14 17:12 * @version: 1.0.0 */ public enum FruitsOne { APPLE(\"Red\",\"Fragrance\",\"Sweet\"), BANANA(\"Yellow\",\"None\",\"Sweet\"), PEAR(\"Green\",\"None\",\"Sweet\"), PEACH(\"Pink\",\"Fragrance\",\"Sweet\"), ORANGE(\"Orange\",\"Fragrance\",\"Sweet\"); private final String color; private final String smell; private final String taste; //constructor FruitsOne(String color,String smell,String taste){ this.color = color; this.smell = smell; this.taste = taste; } public double getPrice(){ switch (this){ case APPLE: return 12.45d; case BANANA: return 23.45d; case PEAR: return 16.56d; case PEACH: return 16.67d; case ORANGE: return 19.45d; default: return 0.0d; } } } 枚举时无法访问到构造方法和通过反射调用方法的： public static void main(String[] args) { System.out.println(FruitsOne.APPLE.getPrice()); System.out.println(FruitsOne.BANANA.color); Class\u003cFruitsOne\u003e fruitsOneClass = FruitsOne.class; Class\u003c? extends FruitsOne\u003e aClass = FruitsOne.ORANGE.getClass(); Class\u003cFruitEnum1\u003e fruitEnum1Class = FruitEnum1.class; Constructor\u003c?\u003e[] declaredConstructors = fruitEnum1Class.getDeclaredConstructors(); for (Constructor\u003c?\u003e constructor : declaredConstructors) { constructor.setAccessible(true); try { constructor.newInstance(\"33\",\"\",\"\"); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } /////不允许通过构造方法创建美剧对象！！ Method[] declaredMethods = aClass.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { declaredMethod.setAccessible(true); if (declaredMethod.getName().equals(\"getPrice\")) try { declaredMethod.invoke(ORANGE); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 枚举的values（）方法： for (FruitsOne one:FruitsOne.values()) { System.out.println(one.smell); } 枚举的方法添加： /** * @description: Todo * @author: ZZS * @date: 2022/9/15 9:33 * @version: 1.0.0 */ public enum FruitTwo { APPLE{ public void eatMethod(){ System.out.println(\"Use mouth;\"); } public String Place(){ return \"I am in Sichuan\"; } }, BANANA{ public void eatMethod(){ System.out.println(\"Use ear\"); } public String Place(){ return \"I am in Sichuan\"; }}, PEAR{@Override public void eatMethod(){ System.out.println(\"Use Hands\"); } public String Place(){ return \"I am in Sichuan\"; }}, PEACH{@Override public void eatMethod(){ System.out.println(\"Use feet\"); } public String Place(){ return \"I am in Sichuan\"; } }, ORANGE{@Override public void eatMethod(){ System.out.println(\"Use Other\"); } public String Place(){ return \"I am in Sichuan\"; } }; public double amount(double weight){ switch (this) { case APPLE: return weight*1.34; case BANANA: return weight*2.34; case PEAR: case PEACH: return weight*3.34; case ORANGE: return weight*4.34; default: return 0; } } public abstract void eatMethod(); public abstract String Place(); } 枚举的valueOf(String)方法的含义与用法**： public static void main(String[] args) { FruitTwo.APPLE.eatMethod(); for (FruitTwo two : FruitTwo.values()) { two.eatMethod(); } FruitTwo.valueOf(\"APPLE\").eatMethod(); } //FruitTwo.valueOf(\"APPLE\").eatMeth","date":"2022-06-05","objectID":"/java%E6%9E%9A%E4%B8%BE/:1:2","tags":["Java"],"title":"Java枚举","uri":"/java%E6%9E%9A%E4%B8%BE/"},{"categories":["Java"],"content":"了解lambda表达式和四大接口","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"匿名内部类就是没有名字的内部类，必须在创建时使用 new 语句来声明类。正因为没有名字，所以匿名内部类只能使用一次。使用匿名内部类还有个前提… 1.lambda表达式 ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"1.1 匿名内部类和函数式接口 1.1.1 匿名内部类 匿名内部类就是没有名字的内部类，必须在创建时使用 new 语句来声明类。正因为没有名字，所以匿名内部类只能使用一次。使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。 不使用匿名内部类实现： abstract class Person { public abstract void eat(); } class Child extends Person { public void eat() { System.out.println( \"eat something\" ); } } public class Demo { public static void main(String[] args) { Person p = new Child(); p.eat(); } } 使用匿名内部类实现： abstract class Person { public abstract void eat(); } public class Demo { public static void main(String[] args) { Person p = new Person() { public void eat() { System.out.println(\"eat something\"); } }; p.eat(); } } 可以看到，我们直接将抽象类Person中的方法在大括号中实现了 这样便可以省略一个类的书写 并且，匿名内部类还能用于接口上 @FunctionalInterface public interface Runnable { /** * When an object implementing interface \u003ccode\u003eRunnable\u003c/code\u003e is used * to create a thread, starting the thread causes the object's * \u003ccode\u003erun\u003c/code\u003e method to be called in that separately executing * thread. * \u003cp\u003e * The general contract of the method \u003ccode\u003erun\u003c/code\u003e is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } //匿名内部类 实现一个接口，实现其方法 Runnable r = new Runnable() { public void run() { for (int i = 1; i \u003c= 5; i++) { System.out.print(i + \" \"); } } }; Thread t = new Thread(r); t.start(); 匿名内部类以关键字new开头，后面接接口名以及英文小括号，表示定义一个是实现该接口但没有显示名的类。大括号中的代码重写run方法。 1.1.2 函数式接口 函数式接口是一种包含单一抽象方法的接口，但不一定只有一个方法，类通过为接口中的方法提供实现来实现接口。（函数式接口中，抽象方法只能有一个，但是可以有默认方法、静态方法等非抽象方法），可以使⽤@FunctionalInterface标记该接⼝为函数式接⼝。 @FunctionalInterface public interface FilenameFilter { /** * Tests if a specified file should be included in a file list. * * @param dir the directory in which the file was found. * @param name the name of the file. * @return \u003ccode\u003etrue\u003c/code\u003e if and only if the name should be * included in the file list; \u003ccode\u003efalse\u003c/code\u003e otherwise. */ boolean accept(File dir, String name); } java8之前，接口中的所有方法都被默认为抽象方法，可以省略abstract关键字，由于接口中的所有方法都是public方法，可以省略访问修饰符。 @FunctionalInterface注解的优点： ​ @FunctionalInterface注解会触发编译时校验，有助于确保接口符合要求。如果接口不包含或包含多个抽象方法，程序将提示编译错误。 @FunctionalInterface public interface MyInterface { void test1(); //int test2(); default String worldDefault(){ return \"This is default method !\"; } static String worldStatic(){ return \"This is static method !\"; } } test1和test2只能存在一个，因为加了@FunctionalInterface注解，而test1和test2都默认为抽象方法，触发了@FunctionalInterface的校验机制。 @FunctionalInterface public interface MyChildyInterface extends MyInterface{ int test2(); } 一个接口可以继承多个接口，如果一个接口继承现有的函数式接口后，又添加了其他抽象方法后，该接口就不再是函数式接口。因此MyChildyInterface不属于函数式接口，因为它包含两个抽象方法父接口的test1()和现有的test2()，添加@FunctionalInterface注解后会提示编译错误。 特点： （1）有且仅有一个抽象方法(接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字) （2）但可以有default、static方法，由于这两种方法都有相应的实现，所以与“有且仅有一个抽象方法”并不矛盾 （3）可继承Object类中的public方法（因为任何一个类都继承Object类，包含了来自 java.lang.Object里对这些抽象方法的实现，也不属于抽象方法） （4）函数式接口里允许子接口继承多个父接口，但每个父接口中都只能存在一个抽象方法，且必须是相同的抽象方法。 ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:1","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"1.2 Lambda表达式 lambda可以理解为是jdk8中⼀个语法糖，它可以对某些匿名内部类的写法进⾏简化，它是函数式编程思想的⼀个重要体现。lambda表达式不关注是什么对象，更关注对数据进⾏了什么操作。lambda允许把函数作为参数传⼊到另⼀个⽅法中。简而⾔之，可以看成是对匿名内部类的简写，使⽤lambda表达式时，接⼝必须是函数式接⼝。 //匿名内部类 实现一个接口，实现其方法 Runnable r = new Runnable() { public void run() { for (int i = 1; i \u003c= 5; i++) { System.out.print(i + \" \"); } } }; Thread t = new Thread(r); t.start(); //Lambda表达式 Runnable r1 = () -\u003e{ for (int i = 1; i \u003c= 5; i++) { System.out.print(i + \" \"); } }; Thread t1 = new Thread(r); t1.start(); lambda表达式必须匹配接口中单一抽象方法的参数类型和返回类型。lambda表达式属于函数式接口中单一抽象方法的实现，可以将lambda表达式视为实现接口的匿名内部类的主体，这就是lambda表达式必须与抽象方法兼容的原因，其参数类型和返回类型必须匹配该方法的签名。所实现的方法的名称并不重要，它不会作为lambda表达式语法的一部分。 比如：在上面lambda表达式中，并没有看到实现的Runnable接口的抽象方法run()的方法名称，但是该lambda表达式的参数类型和返回类型和抽象方法run()是相同的，该表达式小括号里面没有参数，表示是无参，同时print()方法返回的是void，和Runnable接口中抽象方法run()的参数类型和返回值一样。 FilenameFilter的匿名内部类实现及Lambda表达式： //FilenameFilter的匿名内部类实现 File file = new File(\"D:\\\\Study\\\\project\\\\LambdaAndFunction\\\\src\\\\main\\\\java\\\\com\\\\zzy\\\\lambdaandfunction\\\\LambdaDemo\"); String[] names = file.list(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".java\"); } }); System.out.println(Arrays.asList(names)); //Lambda表达式实现FilenameFilter接口 File file1 = new File(\"D:\\\\Study\\\\project\\\\LambdaAndFunction\\\\src\\\\main\\\\java\\\\com\\\\zzy\\\\lambdaandfunction\\\\LambdaDemo\"); String[] names1 = file1.list( (dir, name) -\u003e name.endsWith(\".java\") ); System.out.println(Arrays.asList(names1)); 参数包含在小括号中，但并未声明类型。在编译时，编译器发现list方法传入一个FilenameFilter类型的参数，从而获知其单一抽象方法accept()的签名，进而了解accept()的参数为File和String，因此兼容lambda表达式匹配的类型。由于accept()方法的返回类型是布尔值，所以lambda表达式返回值也是布尔值。 lambda表达式的优化： //1.无参无返回值 void test1(); //抽象方法 MyInterface my1 = () -\u003e { System.out.println(\"lambda优化1\"); }; //lambda优化2 如果{}中执⾏语句只有1句，且⽆返回值，{}可以省略 MyInterface my2 = () -\u003e System.out.println(\"lambda优化2\"); //2.无参有返回值 int test2(); //抽象方法 MyInterface my3 = () -\u003e { return 1; }; //lambda优化2 如果{}中执⾏语句只有1句，且有返回值，{}可以省略，但是必须同时省略return MyInterface my4 = () -\u003e 2; //3.有参无返回值 void test3(int a); //抽象方法 MyInterface my5 = (int a) -\u003e { System.out.println(\"lambda优化\"+ a); }; //lambda优化2 如果形参列表只有⼀个参数可以省略，数据类型和() MyInterface my6 = a -\u003e System.out.println(\"lambda优化\"+ a); //4.有参有返回值 int test4(int a, int b, int c); //抽象方法 MyInterface my7 = (int a, int b) -\u003e { return a + b ; }; //lambda优化2 形参列表数据类型可以省略，程序可以⾃⼰推断 MyInterface my8 = (a, b) -\u003e a + b ; 小括号中参数类型可以省略，如果lambda表达式中，函数体只有一个语句，可以不需要使用{}包裹，可以省略return。如果有多个语句，则必须使用{}包裹起来，并且不能省略return关键字。 特点： 无参数，无返回值 （）-\u003e System.out.println(“aaaaaaaa”); 一个参数，并无返回值 （x）-\u003e System.out.println(x); 只有一个参数，小括号可以不写 x -\u003e System.out.println(x); 有两个以上的参数，并且Lambda体中有多条语句 （x,y）-\u003e x+y ; 如果Lambda体中只有一条语句，那么return 和大括号都可以省略不写; Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出数据 类型，即”类型推断” 总结：lambda表达式属于函数式接口中单一抽象方法的实现。它返回一个指定接口类型的对象实例。 lambda表达式既可以是方法的参数，也可以是方法的返回类型，还可以被赋给引用。 //1、lambda表达式作为方法的参数 File file1 = new File(\"D:\\\\Study\\\\project\\\\LambdaAndFunction\\\\src\\\\main\\\\java\\\\com\\\\zzy\\\\lambdaandfunction\\\\LambdaDemo\"); String[] names1 = file1.list((dir, name) -\u003e name.endsWith(\".java\")); System.out.println(Arrays.asList(names1)); //2、lambda表达式作为方法的返回类型 public static void main(String[] args) { String[] array={\"abc\", \"jk\", \"aghjghj\", \"u\"}; System.out.println(Arrays.toString(array)); //排序,长度由大到小输出 //Arrays.sort(array, newComparator()); Arrays.sort(array, (a, b) -\u003e b.length() - a.length()); System.out.println(Arrays.toString(array)); } // 函数式接口 作为返回值类型 返回的是 其实例 实现类对象 private static Comparator\u003cString\u003e newComparator() { //return 的是函数式接口的实例 return (a, b) -\u003e b.length() - a.length(); } //3、lambda表达式赋给引用 Runnable r1 = () -\u003e{ for (int i = 1; i \u003c= 5; i++) { System.out.print(i + \" \"); } }; ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:2","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"1.3 方法引用 方法引用（ Method References ）是一种语法糖 ，它本质上就是Lambda 表达式，Lambda 表达式是函数式接口的实例，所以说方法引用也是函数式接口的实例。 若lambda体中的内容有方法已经实现了，我们可以使用“方法引用”,方法引用是Lambda表达式 的另外一种表现形式,属于lambda表达式的一种简化语法。（lambda表达式和方法引用在任何情 况下都不能脱离上下文存在，上下文指定了将表达式赋给哪个函数式接口。） 如果说lambda表达式本质上是将方法作为对象进行处理，那么方法引用就是将现有方法作为lambda表达式进行处理。 方法引用的一般语法是: Qualifier::MethodName 使用双冒号（::）将实例引用或类名与方法分开。 MethodName 是方法的名称。 Qualifier告诉哪里的方法。 List\u003cInteger\u003e list1 = Arrays.asList(82,22,34,50,9); List\u003cInteger\u003e list2 = Arrays.asList(82,22,34,50,9); //使用lambda表达式 list1.sort( (a,b) -\u003e a-b ); //使用方法引用：对一个Integer列表进行排序，因为Integer中已经存在静态的比较方法compare()，因此可以直接用静态方法引用的方式来调用 list2.sort(Integer::compare); System.out.println(list1); System.out.println(list2); //[9, 22, 34, 50, 82] //[9, 22, 34, 50, 82] list1.sort( (a,b) -\u003e a-b )是对Comparator接口的compare方法进行实现，而list2.sort(Integer::compare)是引用现有的Integer的compare方法。 1.3.1 静态方法的引用 静态方法的方法引用：Class::staticMethod Stream.generate(()-\u003eMath.random()) .limit(10) .forEach(f-\u003eSystem.out.println(f)); public static double random() { return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble(); } generate(Supplier s)方法传入Supplier【供给型接口】这个函数式接口作为参数，get()方法不传入参数，产生一个结果，和Math类的random()签名兼容。 Stream.generate(Math::random) .limit(10) .forEach(System.out::println); 因此方法引用 Math::random 表示该方法是Supplier接口的实现。 1.3.2 特定类型的任意对象的实例方法的方法引用 实例方法的方法引用：Class::instanceMethod （1）String.length() 通过类名调用实例方法，当上下文提供s值时，它将用作方法的目标而不是方法的参数。 Stream.of(\"i\",\"have\",\"an\" ,\"apple\") .map( s-\u003es.length() ) .forEach( f-\u003eSystem.out.println(f) ); Stream.of(\"i\",\"have\",\"an\" ,\"apple\") .map(String::length) .forEach(System.out::println); （2）多参数实例方法 如果通过类名引用一个传入多个参数的方法，则上下文提供的第一个参数将作为方法的目标，第二个参数将作为方法的参数。 //方法引用语法调用第一个元素的compareTo（）方法，将第二个参数作为该方法的参数 List\u003cString\u003e collect1 = Arrays.asList(\"i\", \"have\", \"an\", \"apple\").stream() .sorted((s1, s2) -\u003e s1.compareTo(s2)) .collect(Collectors.toList()); System.out.println(collect1); List\u003cString\u003e collect2 = Arrays.asList(\"i\", \"have\", \"an\", \"apple\").stream() .sorted(String::compareTo) .collect(Collectors.toList()); System.out.println(collect2); 1.3.3 引用特定对象的实例方法 引用特定对象的实例方法: Object::instanceMethod 如果通过对象传入参数，则上下文提供的参数用作方法的参数。 //特定对象的实例方法引用适用于lambda表达式的主体中仅仅调用了某个对象的某个实例方法的场景。 Arrays.asList(new String[] {\"a\", \"c\", \"b\"}).stream().forEach(s -\u003e System.out.println(s)); Arrays.asList(new String[] {\"a\", \"c\", \"b\"}).stream().forEach(System.out::println); 1.3.4 构造函数的引用 构造函数的引用： ClassName::new 根据字符串列表来创建相应的Person引用列表 –\u003e 将每一个字符串映射到Person类 List\u003cString\u003e names = Arrays.asList(\"Grace Hopper\", \"Barbara Liskov\", \"Ada Lovelace\", \"Karen Spärck Jones\"); List\u003cPerson\u003e people1 = names.stream() .map(name -\u003e new Person(name)) .collect(Collectors.toList()); List\u003cPerson\u003e people2 = names.stream() .map(Person::new) .collect(Collectors.toList()); System.out.println(people1); System.out.println(people2); //[Person{name='Grace Hopper'}, Person{name='Barbara Liskov'}, Person{name='Ada Lovelace'}, Person{name='Karen Spärck Jones'}] //[Person{name='Grace Hopper'}, Person{name='Barbara Liskov'}, Person{name='Ada Lovelace'}, Person{name='Karen Spärck Jones'}] 需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表保持一致。 Person::new 的作用是引用Person类中的构造函数，执行Person类中的哪个构造函数，由上下文决定，由于上下文提供一个字符串，所以执行由一个参数传入的String构造函数。 1.3.5 数组构造方法引用 数组构造方法引用：数据类型[]::new List\u003cString\u003e names =Arrays.asList(\"Grace Hopper\", \"Barbara Liskov\", \"Ada Lovelace\",\"Karen Spärck Jones\"); Person[] array = names.stream() .map(Person::new) .toArray(Person[]::new); for (Person person:array) { System.out.println(person); } toArray方法传入的参数为数组对象， toArray 方法参数创建了一个大小合适的 Person 引用数组，并采用经过实例化的 Person 实例进行填充。 1.3.6 调用父类或本类方法引用 调用父类或本类方法引用：this::方法名 super::方法名 //接口 public interface MyInterface2 { void testMethod(); } //父类 public class father { public void say(){ System.out.println(\"father\"); } } //子类 public class son extends father{ @Override public void say() { System.out.println(\"son\"); } public void test(){ //lambda常规写法 MyInterface2 my3 = ()-\u003ethis.say(); my3.testMethod(); MyInterface2 my4 = ()-\u003esuper.say(); my4.testMethod(); //调⽤⽗类或本类⽅法引⽤ MyInterface2 my5 = this::say; my5.testMethod(); ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:3","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"2.1 consumer接口（消费型接口） 单一抽象方法为：void accept(T t); 默认方法： andThen(Consumer after) 方法 描述 void accept(T t) 对给定的参数执行此操作 default Consumer andThen(Consumer after) 当前Consumer执行后, 要执行的操作 @FunctionalInterface public interface Consumer\u003cT\u003e { void accept(T t); default Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e { accept(t); after.accept(t); }; } } 2.1.1 accept() 方法传入一个泛型参数并返回void Consumer\u003cString\u003e con = str -\u003e System.out.println(str); con.accept(\"Consumer是一个消费型函数式接口\"); 2.1.2 andThen() 在当前Consumer后添加操作的方法，该方法生成一个组合的Consumer, 它依次执行此Consumer和after参数提供的操作。andThen()所用组合中的Consumer都共用同一个输入。andThen接收一个Consumer接口，返回的也是一个Consumer接口 Consumer\u003cString\u003e question = q1-\u003eSystem.out.println(\"A: 请问您是 \" + q1 + \" 吗?\"); Consumer\u003cString\u003e answer = a1-\u003e System.out.println(\"B: 是的, 我是 \" + a1); Consumer\u003cString\u003e confirm = c1-\u003e System.out.println(\"A: 啊? 真的嘛? 您真的是 \" + c1 + \" 吗?\"); Consumer\u003cString\u003e angery = a2-\u003e System.out.println(\"B: 当然了, 我就是 \" + a2 + \". 你要我说几遍?\"); //组合的 Consumer 公用了相同的输入 question.andThen(answer).andThen(confirm).andThen(angery).accept(\"张三\"); 运行结果： A: 请问您是 张三 吗? B: 是的, 我是 张三 A: 啊? 真的嘛? 您真的是 张三 吗? B: 当然了, 我就是 张三. 你要我说几遍? 当调用 andThen方法的时候，并不是执行 (T t) -\u003e { accept(t); after.accept(t); } 这段代码，而是返回了一个 Consumer 接口，注意它的结构是给一个对象 t，然后大括号中消费 t。处理逻辑是当前 Consumer 执行 accept 方法，然后再让 after这个 Consumer 执行 accept方法。理解 andThen 方法返回的结构特别重要。 相当于分别执行了一次 question.accept()； answer.accept()； confirm.accept() ； angery.accept()；。 如果执行任一操作引发异常, 则将其转发给组合操作的调用者，如果执行当前Consumer抛出异常, 则不会执行after操作。如果after参数为null抛出异常NullPointerException。 2.1.3 其他Consumer接口 java.util.function包定义了三种Consumer的基本变体以及一种双参数形式。 接口 单一抽象方法 IntConsumer void accept(int x) DoubleConsumer void accept(double x) LongConsumer void accept(long x) BiConsumer void accept(T t,U u) 基本变体的Consumer接口，指定了accept方法的参数类型。 //声明函数对象 IntConsumer IntConsumer intConsumer = i -\u003e System.out.println(i); intConsumer.accept(123); IntConsumer接口的accept方法 void accept(int value); 指定了输入参数为int型，如果输入参数为其他类型，则编译会报错。 BiConsumer是一种双参数形式接口，BiConsumer接口的accept()方法传入两个泛型参数，这两个泛型参数应为不同的类型。 // 声明函数对象 biconsumer BiConsumer\u003cInteger,String\u003e biconsumer = (int1, str2) -\u003e System.out.println(\"参数1为整型，值为: \"+int1+\",参数2为字符串型，值为：\"+str2); // BiConsumer.accept()方法接收参数 biconsumer.accept(20,\"BiConsumer.accept()方法接收参数\"); java.util.function 包定义了BiConsumer接口的三种变体，每种变体的第二个参数为基本数据类型。以 ObjIntConsumer 接口为例，accept方法传入两个参数，分别为泛型参数和int参数。ObjLongConsumer和ObjDoubleConsumer接口的定义与ObjIntConsumer类似。 // 声明函数对象 consumer1 ObjIntConsumer\u003cString\u003e consumer1 = (str1,int1) -\u003e System.out.println(\"参数为字符串型，值为：\"+str1+\",第二个参数为整型值：\"+int1); // BiConsumer.accept()方法接收参数 consumer1.accept(\"ObjIntConsumer.accept()方法接收参数\",20); ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:4","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"2.2 Supplier接口（供给型接口） 单一抽象方法为： T get(); 方法 描述 T get() 获得结果 2.2.1 get() get()方法不接受任何参数，只返回泛型类型的值。 调用Supplier接口时，不要求每次都返回一个新的或不同的结果。 Supplier\u003cDouble\u003e randomValue = () -\u003e Math.random(); System.out.println(\"获取随机数：\" + randomValue.get()); System.out.println(\"再次获取随机数：\" + randomValue.get()); 运行结果： 获取随机数：0.3172168289009717 再次获取随机数：0.31141812585953 2.2.3 其他Supplier接口 接口 单一抽象方法 IntSupplier int getAsInt() DoubleSupplier double getAsDouble() LongSupplier long getAsLong() BooleanSupplier boolean getAsBoolean() IntSupplier接口包含的单一抽象方法为 getAsInt，它返回一个 Integer 型数据。其他接口和IntSupplier类似。 IntSupplier randomIntValue = ()-\u003e (int) (Math.random()*10); System.out.println(\"获取数：\" + randomIntValue.getAsInt()); ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:5","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"2.3 Predicate接口（断言型接口） 单一抽象方法： boolean test(T t) 默认方法： and(Predicate other) ​ or(Predicate other) ​ negate(Predicate other) 静态方法：isEqual() 用途 判断对象是否符合某个条件（传入一个参数，返回一个布尔值） 方法 描述 boolean test(T t) 在给定的参数上评估这个谓词 default Predicate and(Predicate other) 接收一个Predicate类型，也就是将传入的条件和当 前条件以并且的关系过滤数据 default Predicate negate() 返回表示此谓词的逻辑否定的谓词。 default Predicate or(Predicate other) 接收一个Predicate类型，将传入的条件和当前的条 件以或者的关系过滤数据。 static Predicate isEqual(Object targetRef) 根据 Objects.equals(Object) 测试两个参数是否相等。 2.3.1 test() boolean test(T t); test()方法传入一个泛型参数，返回一个布尔值。 Predicate\u003cString\u003e predicate = str -\u003e str.length() \u003e 7; System.out.println(\"长度是否大于7：\"+predicate.test(\"scbjacbskldjcnosd\"));//true System.out.println(\"长度是否大于7：\"+predicate.test(\"uhsdk\"));//false 2.3.2 and() default Predicate\u003cT\u003e and(Predicate\u003c? super T\u003e other) { Objects.requireNonNull(other); return (t) -\u003e test(t) \u0026\u0026 other.test(t); } and() 生成一个组合断言, 表示该断言和另一个断言的短路逻辑与(AND). 在评估组合断言时, 如果当前断言为 false, 则不再对另一个断言进行评估. 在评估任一断言期间抛出的任何异常都将转发给调用者; 如果在前断言的求值过程中发生了异常, 则不再对另一个断言求值. //and() Predicate\u003cString\u003e p1 = p -\u003e p.contains(\"H\"); Predicate\u003cString\u003e p2 = p -\u003e p.length() \u003e 5; boolean isValid = p1.and(p2).test(\"Hello world\");//true\u0026\u0026true -\u003e true System.out.println(\"是否有效：\"+isValid); 2.3.3 or() default Predicate\u003cT\u003e or(Predicate\u003c? super T\u003e other) { Objects.requireNonNull(other); return (t) -\u003e test(t) || other.test(t); } or()生成一个组合断言, 表示该断言和另一个断言的短路逻辑或(OR). 在评估组合断言时, 如果当前断言为 true, 则不再对另一个断言进行评估. 在评估任一断言期间抛出的任何异常都将转发给调用者; 如果在前断言的求值过程中发生了异常, 则不再对另一个断言求值. //or() Predicate\u003cString\u003e o1 = p -\u003e p.contains(\"k\"); Predicate\u003cString\u003e o2 = p -\u003e p.length() \u003e 20; boolean isValid2 = o1.or(o2).test(\"Hello world\");//等同于 return p1.test(s) || p2.test(s) -\u003e false; System.out.println(\"是否有效2：\"+isValid2); 2.3.4 negate() default Predicate\u003cT\u003e negate() { return (t) -\u003e !test(t); } negate()获取一个否定当前断言的断言 //negate() Predicate\u003cString\u003e n1 = p -\u003e p.length() \u003e 20; boolean isValid3 = n1.negate().test(\"Hello world\");//等同于 return !p1.test(s) ; System.out.println(\"是否有效3：\"+isValid3); 2.3.5 isEqual() static \u003cT\u003e Predicate\u003cT\u003e isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -\u003e targetRef.equals(object); } 生成一个断言, 该断言根据 Objects.equals(Object) 测试两个参数是否相等。 //isEqual() Predicate\u003cString\u003e e = Predicate.isEqual(\"abc\"); System.out.println(\"abc isEqual abc:\"+e.test(\"abc\")); System.out.println(\"abc isEqual bcd:\"+e.test(\"bcd\")); ","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:6","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java"],"content":"2.4 Function接口（功能型接口） 单一抽象方法： R apply(T t) 默认方法： compose(Function before) ​ andThen(Function after) 静态方法：identity() 方法 描述 R apply(T t) 将此函数应用于给定的参数。 default Function andThen(Function after) 返回一个组合函数，首先将该函数应用于其输入，然后将 after函数应用于结果（先执行当前对象的apply方法，再执行after对象的方法）。 default Function compose(Function before) 返回一个组合函数，首先将 before函数应用于其输入，然后 将此函数应用于结果（先执行before对象的apply，再执行当前对象的apply，将两个执行逻辑串起来）。 static Function identity() 返回其输入参数的函数 2.4.1 apply() R apply(T t); apply方法将T类型的泛型输入参数转换为R类型泛型输出值。 Function\u003cInteger,Integer\u003e f1 = f -\u003e f*2; Function\u003cInteger,Integer\u003e f2 = f -\u003e f*f; Function\u003cInteger,Integer\u003e f3 = f -\u003e f+10; //apply System.out.println(f1.apply(3));//执行f1.apply(3)方法，----\u003e 3*2=6 List\u003cString\u003e names = Arrays.asList(\"Mal\", \"Wash\", \"Kaylee\", \"Inara\", \"Zoë\", \"Jayne\", \"Simon\", \"River\", \"Shepherd Book\"); List\u003cInteger\u003e list = names.stream() .map(s -\u003e { return s.length();//apply的传入参数为s，Function的apply方法的实现为输出s的长度，返回s的长度 }) .collect(Collectors.toList()); System.out.println(\"list:\"+list); map方法传入的对象为Function类型，apply方法的实现为将流中的元素通过lambda表达式将每个元素都转化为元素的长度，然后返回。 2.4.2 andThen() default \u003cV\u003e Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e after.apply(apply(t)); } andThen()生成一个组合函数, 该函数首先将当前Function作为其输入, 然后将after函数应用于输入后产生的结果。 返回一个使用当前Function作为输入, 再应用after参数生成结果的Function andThen()方法主要用于组装两个函数生成一个新的函数, 这个函数为原有函数的结果提供更强的快捷的拓展的运算的方法. //andThen() //先执行 3*2=6，再执行 6*6=36 System.out.println(f1.andThen(f2).apply(3)); System.out.println(f2.apply(f1.apply(3))); //先执行 3*2=6，再执行 6*6=36 ，最后执行 36+10=46 System.out.println(f1.andThen(f2).andThen(f3).apply(3)); System.out.println(f3.apply ( f2.apply( f1.apply(3) ) ) ); 执行f1.andThen(f2).apply(3)相当于执行f2.apply(f1.apply(3))，f2.apply(f1.apply(3))先执行括号里面的result=f1.apply(3),再将该结果作为传入参数，执行f2.apply(result)。使用andThen()可以避免无限嵌套，比如：f3.apply(f2.apply(f1.apply(3)))。 2.4.3 compose() default \u003cV\u003e Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before) { Objects.requireNonNull(before); return (V v) -\u003e apply(before.apply(v)); } 参数类型 参数名称 参数描述 类型参数 T 输入到函数的类型 类型参数 R 从函数返回的结果的类型 类型参数 V before 函数和组合函数的输入类型 Function\u003c? super V,? extends T\u003e before 应用当前函数后再应用的函数 生成一个组合函数, 该函数首先将 before 函数应用于当前函数的输入, 然后将当前函数应用于结果. 返回一个先将输入应用于 before 函数, 再将产生的结果应用于当前函数的 Function. compose() 方法主要用于组装两个函数生成一个新的函数, 组合的新函数实际上是, before函数为当前 Function 做了前置的处理, 再调用当前 Function. //先执行 3*3 = 9，再执行 9*2=18 System.out.println(f1.compose(f2).apply(3)); System.out.println(f1.apply(f2.apply(3))); //先执行 10+3=13，再执行 13*13=169，最后执行 169*2 = 338 System.out.println(f1.compose(f2).compose(f3).apply(3)); System.out.println(f1.apply(f2.apply(f3.apply(3)))); 2.4.4 identity() static \u003cT\u003e Function\u003cT, T\u003e identity() { return t -\u003e t; } 参数类型 参数名称 参数描述 类型参数 T 函数的输入和输出对象的类型 生成一个总是返回输入的函数 identity()就是Function接口的一个静态方法。Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -\u003e t形式的Lambda表达式。 Map\u003cString, Integer\u003e map = Arrays.asList(\"a\",\"abc\",\"love\") .stream() .map(Function.identity()) .map(str -\u003e str) .collect( Collectors.toMap(Function.identity(), str -\u003e str.length()) ); System.out.println(map); Function\u003cString, String\u003e idHello = Function.identity(); String param = \"Jack\"; System.out.println(\"是否总是相等? \" + idHello.apply(param).equals(param)); param = \"猫猫\"; System.out.println(\"是否总是相等? \" + idHello.apply(param).equals(param)); 2.4.5 其他Function接口 接口 单一抽象方法 IntFunction R apply(int value) DoubleFunction R apply(double value) LongFunction R apply(long value) ToIntFunction int applyAsInt(T value) ToDoubleFunction double applyAsDouble(T value) ToLongFunction long applyAsLong(T value) DoubleToIntFunction int applyAsInt(double value) DoubleToLongFunction long applyAsLong(double value) IntToDoubleFunction double applyAsDouble(int value) IntToLongFunction long applyAsLong(int value) LongToDoubleFunction double applyAsDouble(long value) LongToIntFunction int applyAsInt(long value) BiFunction R apply(T t, U u) IntFunction：R apply(int value) ，apply()接收的参数的int，返回的值为泛型参数 //IntFunction IntFunction\u003cString\u003e i1 = i -\u003e i+\"*4=\"+i*4; System.out.println(i1.apply","date":"2022-06-05","objectID":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:7","tags":["Java","Spring"],"title":"lambda表达式和四大接口","uri":"/1.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["分布式系统"],"content":"了解MapReduce.","date":"2022-05-20","objectID":"/springcloud/","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"SpringCloud Spring Cloud 包括 Spring Cloud Gateway、Spring Cloud Config、Spring Cloud Bus 等近 20 个服务组件，这些组件提供了服务治理、服务网关、智能路由、负载均衡、熔断器、监控跟踪、分布式消息队列、配置管理等领域的解决方案。 Eureka Eureka是spring cloud中的一个负责服务注册与发现的组件。遵循着CAP理论中的A(可用性)P(分区容错性)。 一个Eureka中分为eureka server和eureka client。其中eureka server是作为服务的注册与发现中心。eureka client既可以作为服务的生产者，又可以作为服务的消费者。 Eureka Server：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。 Eureka Client：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒）。 ","date":"2022-05-20","objectID":"/springcloud/:0:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"新建Eureka Server 新建springBoot项目 1.引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e \u003c/dependency\u003e 表明此是一个Eureka Server 2.系统配置 启动类中添加注解@EnableEurekaServer yml配置 server: port: 8761 #该 Module 的端口号 eureka: instance: hostname: localhost #eureka服务端的实例名称， client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己就是注册中心，职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #单机版服务注册中心 3.使用浏览器访问 Eureka 服务注册中心主页，地址为“http://localhost:8761/可以看到服务中心以及有哪些已注册的客户端。 ","date":"2022-05-20","objectID":"/springcloud/:1:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"新建Eureka client 在微服务架构中，每个服务都需要注册到Eureka Server 中，也就代表每个服务都需要成为Eureka client 1.引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 表明此是一个Eureka client 2.系统配置 启动类中添加注解@EnableEurekaClient yml配置 server: port: 8001 #服务端口号 spring: application: name: service-one #微服务名称，对外暴漏的微服务名称，也就是注册到server上的名字，十分重要 eureka: client: #将客户端注册到 eureka 服务列表内 service-url: defaultZone: http://localhost:8761/eureka #这个地址是 8761注册中心在 application.yml 中暴露出来额注册地址 （单机版） instance: instance-id: spring-cloud-provider-8001 #自定义服务名称信息 prefer-ip-address: true #显示访问路径的 ip 地址 ########################################## spring cloud 使用 Spring Boot actuator 监控完善信息 # Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点 management: endpoints: web: exposure: include: \"*\" # * 在yaml 文件属于关键字，所以需要加引号 ","date":"2022-05-20","objectID":"/springcloud/:2:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"Eureka Server集群 1.在微服务架构中，一个系统往往由十几甚至几十个服务组成，若将这些服务全部注册到同一个 EurekServer 中，就极有可能导致 Eureka Server 因不堪重负而崩溃，最终导致整个系统瘫痪。解决这个问题最直接的办法就是部署 Eureka Server 集群。 Eureka 中，所有服务都既是服务消费者也是服务提供者，服务注册中心 Eureka Server 也不例外。 在以上的配置中，如果配置了两个Eureka Server，将本身作为client互相注册到对方的信息中，其server配置文件修改为： eureka: instance: hostname: eurekaserver-one prefer-ip-address: true #将其同时作为一个客户端相互发现 client: #将客户端注册到 eureka 服务列表内 register-with-eureka: true fetch-registry: false service-url: defaultZone: http://localhost:8762/eureka/ #其他Eureka Server的地址 那么在整个系统中，所有服务的部分配置修改为（假设我们有两个server分别是8761和8762）： eureka: client: service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/ 负载均衡 服务端负载均衡具有以下特点： 需要建立一个独立的负载均衡服务器。 负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。 可用服务端清单存储在负载均衡服务器上。 客户端负载均衡是将负载均衡逻辑以代码的形式封装到客户端上，即负载均衡器位于客户端。客户端通过服务注册中心（例如 Eureka Server）获取到一份服务端提供的可用服务清单。有了服务清单后，负载均衡器会在客户端发送请求前通过负载均衡算法选择一个服务端实例再进行访问，以达到负载均衡的目的； 客户端负载均衡也需要心跳机制去维护服务端清单的有效性，这个过程需要配合服务注册中心一起完成。 客户端负载均衡具有以下特点： 负载均衡器位于客户端，不需要单独搭建一个负载均衡服务器。 负载均衡是在客户端发送请求前进行的，因此客户端清楚地知道是哪个服务端提供的服务。 客户端都维护了一份可用服务清单，而这份清单都是从服务注册中心获取的。 Ribbon 就是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从 Eureka Server（服务注册中心）中获取服务端列表，然后通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。 配置中心 Spring Cloud Config 是由 Spring Cloud 团队开发的项目，它可以为微服务架构中各个微服务提供集中化的外部配置支持。 将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、数据库）中，对配置的统一管理，以支持各个微服务的运行。 其包含两部分 Config Server：分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。 Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。 Spring Cloud Config 工作流程如下： 开发或运维人员提交配置文件到远程的 Git 仓库。 Config 服务端（分布式配置中心）负责连接配置仓库 Git，并对 Config 客户端暴露获取配置的接口。 Config 客户端通过 Config 服务端暴露出来的接口，拉取配置仓库中的配置。 Config 客户端获取到配置信息，以支持服务的运行。 ","date":"2022-05-20","objectID":"/springcloud/:3:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"搭建Config Server 1.依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-config-server\u003c/artifactId\u003e \u003c/dependency\u003e 2.配置文件yml 本地数据库作储存 server: port: 8888 spring: application: name: config-server cloud: config: label: master server: jdbc: sql: SELECT PROP_KEY, VALUE from PROPERTIES where APPLICATION=? and PROFILE=? and LABEL=? order: 1 discovery: enabled: true service-id: config-server datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3307/mycloud?serverTimezone=GMT%2B8 username: root password: root git仓库作储存(github国内较慢，容易失败) config: server: git: uri: https://gitee.com/yangeryiyi/springcloud-config.git # default-label: master #github现在默认改成main #仓库名 search-paths: - springcloud-config force-pull: true # 如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写 # username: 417535841@qq.com # password: #分支名 label: master 3.启动类加@EnableConfigServer 注解开启 Spring Cloud Config 配置中心功能 其中用本地数据库建表可如下： id created_on application profile label prop_key value 1 service-one dev master server.port 8080 使用git可新建公开仓库springcloud-config，并上传如config-dev.yml配置文件（本例中使用如下） config: info: message version: 1.0 启动项目后可使用浏览器访问“http://localhost:8888/master/config-dev.yml”可查看配置（github可能master改为main） Spring Cloud Config 规定了一套配置文件访问规则，如下表。 访问规则 示例 /{application}/{profile}[/{label}] /config/dev/master /{application}-{profile}.{suffix} /config-dev.yml /{label}/{application}-{profile}.{suffix} /master/config-dev.yml 访问规则内各参数说明如下。 {application}：应用名称，即配置文件的名称，例如 config-dev。 {profile}：环境名，一个项目通常都有开发（dev）版本、测试（test）环境版本、生产（prod）环境版本，配置文件则以 application-{profile}.yml 的形式进行区分，例如 application-dev.yml、application-test.yml、application-prod.yml 等。 {label}：Git 分支名，默认是 master 分支，当访问默认分支下的配置文件时，该参数可以省略，即第二种访问方式。 {suffix}：配置文件的后缀，例如 config-dev.yml 的后缀为 yml。 ","date":"2022-05-20","objectID":"/springcloud/:4:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"搭建 Config 客户端 1.pom文件中引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e 2.配置文件yml 采用本地数据库配置 cloud: config: #默认为master label: master profile: prod discovery: enabled: true service-id: config-server retry: #config自带重试策略 initial-interval: 5000 max-attempts: 5 max-interval: 5000 multiplier: 1.1 config: import: configserver:http://localhost:8888 采用git配置 application: name: service-user cloud: config: label: master #分支名称 name: config #配置文件名称，config-dev.yml 中的 config profile: dev #环境名 config-dev.yml 中的 dev retry: #config自带重试策略 initial-interval: 5000 max-attempts: 5 max-interval: 5000 multiplier: 1.1 config: import: configserver:http://localhost:8888 ","date":"2022-05-20","objectID":"/springcloud/:5:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"刷新配置 配置更新后，Spring Cloud Config 服务端（Server）可以直接从 Git 仓库中获取最新的配置。 除非重启 Spring Cloud Config 客户端（Client），否则无法通过 Spring Cloud Config 服务端获取最新的配置信息。 ","date":"2022-05-20","objectID":"/springcloud/:6:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"手动刷新配置 1.依赖添加（引入 Spring Boot actuator 监控模块。） \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e 2.xml配置（暴露 Spring Boot actuator 的监控节点。） management: endpoints: web: exposure: include: '*' Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点 actuator模块提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP 跟踪等，帮助我们监控和管理Spring Boot 应用。这个模块是一个采集应用内部信息暴露给外部的模块，上述的功能都可以通过HTTP 和 JMX 访问 3.在使用到配置的类中加入 @RefreshScope 注解开启配置刷新 此时改变配置再次访问此客户端会发现仍然是旧值 4.令发送一个 POST 请求刷新 Spring Cloud Config 客户端，通知客户端配置文件已经修改，需要重新拉去配置。 http://localhost:{当前客户端口号}/actuator/refresh 问题： 微服务包含服务较多时，更改配置后，每个客户端都需要去发送此post请求去刷新 ","date":"2022-05-20","objectID":"/springcloud/:6:1","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"动态刷新 Spring Cloud Bus 又被称为消息总线，它能够通过轻量级的消息代理（例如 RabbitMQ、Kafka 等）将微服务架构中的各个服务连接起来，实现广播状态更改、事件推送等功能，还可以实现微服务之间的通信功能。 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka。 当 Git 仓库中的配置发生改变后，向 Config 服务端发送一个 POST 请求，请求路径为“/actuator/refresh”。 Config 服务端接收到请求后，会将该请求转发给服务总线 Spring Cloud Bus。 Spring Cloud Bus 接到消息后，会通知给所有 Config 客户端。 Config 客户端接收到通知，请求 Config 服务端拉取最新配置。 所有 Config 客户端都获取到最新的配置。 1.在配置中心添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--添加消息总线（Bus）对 RabbitMQ 的支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e 采用RabbitMQ 为例 2.在配置中心修改配置 RabbitMQ 相关配置，15672 是web 管理界面的端口，5672 是 MQ 的访问端口 spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点 management: endpoints: web: exposure: include: 'bus-refresh' 3.在client中添加 Spring Cloud Bus 的相关依赖 \u003c!--添加消息总线（Bus）对 RabbitMQ 的支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e 4.在client中的配置文件 bootstrap.yml 中添加以下配置 ##### RabbitMQ 相关配置，15672 是web 管理界面的端口，5672 是 MQ 的访问端口########### spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest 5.当更新配置后向Config Server发送一个 POST 请求，刷新配置。 POST \"http://localhost:{Server端口}/actuator/bus-refresh\" Gateway API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。 API 网关就像整个微服务系统的门面一样，是系统对外的唯一入口。有了它，客户端会先将请求发送到 API 网关，然后由 API 网关根据请求的标识信息将请求转发到微服务实例。 Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。 核心功能 Spring Cloud GateWay 最主要的功能就是路由转发 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。 工作流程： 客户端将请求发送到 Spring Cloud Gateway 上。（如nginx配置将请求悉数转发到gataway服务的端口上） Gateway 通过 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送给 Gateway Web Handler。 Handler 通过指定的过滤器链（Filter Chain），将请求转发到实际的服务节点中，执行业务逻辑返回响应结果。 过滤器可在请求之前或之后执行业务逻辑，例如在请求被转发到相应的服务节点之前，对请求拦截和修改，比如我们的参数校验、权限校验等，在服务节点返回响应给客户端之前也可以对响应进行拦截和处理，如修改响应内容或响应头等。 响应返回给客户端 ","date":"2022-05-20","objectID":"/springcloud/:7:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"Predicate 断言 Spring Cloud Gateway 通过 Predicate 断言来实现 Route 路由的匹配规则，也就是路由转发到哪里的判断条件。 一个路由可能包含多个判断条件 路由需同时满足所有判断条件 当一个请求同时满足多个路由的判断条件，则去匹配首个路由 常见Predicate ： 断言 示例 说明 Path - Path=/dept/list/** 当请求路径与 /dept/list/** 匹配时 Before - Before=2021-10-20T11:47:34.255+08:00[Asia/Shanghai] 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求 After - After=2021-10-20T11:47:34.255+08:00[Asia/Shanghai] 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求 Between - Between=2021-10-20T15:18:33.226+08:00[Asia/Shanghai],2021-10-20T15:23:33.226+08:00[Asia/Shanghai] 在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求 Cookie - Cookie=name,c.biancheng.net 携带 Cookie 且 Cookie 的内容为name=c.biancheng.net 的请求 Header - Header=X-Request-Id,\\d+ 请求头上携带属性 X-Request-Id 且属性值为整数的请求 Method - Method=GET 只有 GET 请求才会被转发 ","date":"2022-05-20","objectID":"/springcloud/:8:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"Filter 过滤器 在微服务架构中，系统由多个微服务组成，所有这些服务都需要这些校验逻辑，此时我们就可以将这些校验逻辑写到 Spring Cloud Gateway 的 Filter 过滤器中。 分类： 按类型分类： 过滤器类型 说明 Pre 类型 这种过滤器在请求被转发到微服务之前可以对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。 Post 类型 这种过滤器在微服务对请求做出响应后可以对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等 按作用范围划分： GatewayFilter：应用在单个路由或者一组路由上的过滤器。 GlobalFilter：应用在所有的路由上的过滤器。 Spring Cloud Gateway 内置了多达 31 种 GatewayFilter，以下常见的几种如下： 路由过滤器 描述 参数 使用示例 AddRequestHeader 拦截传入的请求，并在请求上添加一个指定的请求头参数。 name：需要添加的请求头参数的 key； value：需要添加的请求头参数的 value。 - AddRequestHeader=my-request-header,1024 AddRequestParameter 拦截传入的请求，并在请求上添加一个指定的请求参数。 name：需要添加的请求参数的 key； value：需要添加的请求参数的 value。 - AddRequestParameter=my-request-param,c.biancheng.net AddResponseHeader 拦截响应，并在响应上添加一个指定的响应头参数。 name：需要添加的响应头的 key； value：需要添加的响应头的 value。 - AddResponseHeader=my-response-header,c.biancheng.net PrefixPath 拦截传入的请求，并在请求路径增加一个指定的前缀。 prefix：需要增加的路径前缀。 - PrefixPath=/consumer PreserveHostHeader 转发请求时，保持客户端的 Host 信息不变，然后将它传递到提供具体服务的微服务中。 无 - PreserveHostHeader RemoveRequestHeader 移除请求头中指定的参数。 name：需要移除的请求头的 key。 - RemoveRequestHeader=my-request-header RemoveResponseHeader 移除响应头中指定的参数。 name：需要移除的响应头。 - RemoveResponseHeader=my-response-header RemoveRequestParameter 移除指定的请求参数。 name：需要移除的请求参数。 - RemoveRequestParameter=my-request-param RequestSize 配置请求体的大小，当请求体过大时，将会返回 413 Payload Too Large。 maxSize：请求体的大小。 - name: RequestSize args: maxSize: 5000000 GlobalFilters配置 新建配置类: // * 以下是gateway的全局过滤器，只有调用gateway时才起作用 // * 以下全局filter会按照以下顺序打出 // * Order 越小，pre先执行，而post 最后执行 // * first pre filter // * second pre filter // * third pre filter // * first post filter // * second post filter // * third post filter // * @return // * then 是后过滤，即是下游返回后，返回给客户前的过滤 // * then 后代表返回 response --- zzs 注解 2019.12 @Configuration public class GatewayGlobalFilters { static private Logger log = LoggerFactory.getLogger(GatewayGlobalFilters.class); /*** * 以下提供在Gateway全局过滤器中如可添加Header * 和如何添加Attribute的正确方法 * 两种方式，可以自己根据需求选用。推荐header方式！ * 添加header是请求通过gateway的签名，在微服务构架内通行验证 * 如果需要改变值，采用mutate方式，如下。 * then 是后过滤，即是下游返回后，返回给客户前的过滤 * @return */ @Bean @Order(-1) public GlobalFilter gfa() { return (exchange, chain) -\u003e { exchange.getAttributes() .putIfAbsent( \"X-GATEWAY-TOKEN\",\"S305\" ); // 添加attribute方式 exchange.getRequest() .mutate() .headers( hs -\u003ehs.add( \"X-GATEWAY-HEADER-TOKEN\",\"S305-token\" )); //添加header的方式 log.info(\"first pre filter\"); return chain.filter(exchange) //then 是后过滤，即下游返回后的过滤 .then( Mono.fromRunnable(() -\u003e { log.info(\"third post filter\"); log.info(\"最终返回前测试是否存在Token： {}\",exchange.getAttributes().get( \"X-GATEWAY-TOKEN\" )); })); }; } /*** * 以下提供在Gateway全局过滤器中如移除添加的header * @return */ @Bean @Order(0) public GlobalFilter gfb() { return (exchange, chain) -\u003e { log.info(\"second pre filter\"); return chain.filter(exchange) .then( Mono.fromRunnable(() -\u003e { log.info(\"second post filter\"); exchange.getRequest() .mutate() .headers( hs -\u003e hs.remove( \"X-GATEWAY-HEADER-TOKEN\" ) ); })); }; } /*** * 以下提供在Gateway全局过滤器中如移除添加的Attribute * @return */ @Bean @Order(1) public GlobalFilter gfc() { return (exchange, chain) -\u003e { log.info(\"third pre filter\"); return chain.filter(exchange) //后过滤 .then( Mono.fromRunnable(() -\u003e { log.info(\"测试返回的header:{}\",exchange.getResponse().getStatusCode()); exchange.getAttributes() .remove( \"X-GATEWAY-TOKEN\" ); log.info(\"first post filter\"); })); }; } } 搭建Spring Cloud GateWay 建立springboot’项目后pom文件引入 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!--特别注意：在 gateway 网关服务中不能引入 spring-boot-starter-web 的依赖，否则会报错--\u003e \u003c!-- Spring cloud gateway 网关依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--Eureka 客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdep","date":"2022-05-20","objectID":"/springcloud/:9:0","tags":["分布式系统","SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["分布式系统"],"content":"了解MapReduce.","date":"2022-05-05","objectID":"/mapreduce_lab1/","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"MapReduce_Lab1 MapReduce MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 具体实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。 论文第三节中主要描述的流程图如下： 启动MapReduce, 将输入文件切分成大小在16-64MB之间的文件。然后在一组多个机器上启动用户程序。 其中一个副本将成为master, 剩下的成为worker. master给worker指定任务（M个map任务，R个reduce任务）。master选择空闲的worker给予map或reduce任务 得到Map任务的worker接收切分后的input，执行Map函数，将结果缓存到内存 缓存后的中间结果会周期性的写到本地磁盘，并切分成R份（reducer数量）。R个文件的位置会发送给master, master转发给reducer Reduce worker 收到中间文件的位置信息，通过RPC读取。读取完先根据中间排序，然后按照key分组、合并。 Reduce worker 在排序后的数据上迭代，将中间文件交给reduce 函数处理。最终结果写给对应的output文件（分片） 所有map和reduce任务结束后，master唤醒用户程序 ","date":"2022-05-05","objectID":"/mapreduce_lab1/:0:0","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"Lab 1: ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:0","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"实验目的： 实现一个调用应用程序 Map 和 Reduce 函数并处理读取和写入文件的工作进程，以及一个将任务分发给Worker并处理失败的Worker的协调进程。在本例中完成一个分布式的词频统计功能。 ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:1","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"实验要求： map 阶段应该将中间键划分为 nReduce reduce 任务的桶，其中nReduce是 reduce 任务的数量—— main/mrcoordinator.go传递给MakeCoordinator()的参数。因此，每个映射器都需要创建nReduce个中间文件以供 reduce 任务使用。 worker 实现应该将第 X 个 reduce 任务的输出放在文件mr-out-X中。 主要完成mr/worker.go、mr/coordinator.go和mr/rpc.go里的任务代码。 当作业完全完成时，工作进程应该退出。 ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:2","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"大致流程： ![](MapReduce.assets/未命名文件 (6).png) ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:3","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"任务分配： 根据已提供的代码，我们需要完成coordinator.go也就是Master和Worker，以及负责他们之间通信的RPC的实现。其中Master及Worker的工作流程如下图： ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:4","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"关键代码： Mater关键定义: Master所维护的这些变量为关键参数 c := Coordinator{ files: files, //输入文件数组 nReduce: nReduce, //reduce数量 mapTasks: make([]WorkerState, len(files)), //Map任务数组 reduceTasks: make([]WorkerState, nReduce), //Reduce任务数组 mapCommitCount: 0, //Map完成数 reduceCommitCount: 0, //Reduce完成数 allCommited: false, //程序结束标志 timeout: 10 * time.Second, //检查间隔 } Woker请求任务： 通过RPC循环请求Master分配任务的方法，携带之前产生的WorkID for { args := ApplyTaskArgs{WorkerId: workerId} reply := ApplyTaskReply{} working := call(\"Coordinator.ApplyTask\", \u0026args, \u0026reply) . . } Master接收请求并分配任务ApplyTask： Map任务数根据文件数产生，任务分为三种状态-未分配0；已分配未提交1；已提交2；遍历Map任务数组，查看当前阶段未分配的任务，并返回相关信息，将索引下任务的状态设为1 const ( //未分配0；已分配未提交1；已提交2 TaskFree WorkerState = iota TaskWoring TaskCommit ) // map 阶段Map任务数根据文件数产生 func (c *Coordinator) ApplyTask(args *ApplyTaskArgs, reply *ApplyTaskReply) error { for fileId, fileName := range c.files { if c.mapTasks[fileId] != TaskFree { continue } reply.TaskId = fileId reply.Filename = fileName reply.Type = MapTask reply.BucketNumber = c.nReduce c.mapTasks[fileId] = TaskWoring // 后台协程，处理超时的 task // 分发完 task 就可以返回了 return nil } // reduce 阶段 for fileId, taskState := range c.reduceTasks { // task already dispatched if taskState != TaskFree { continue } reply.TaskId = fileId reply.Filename = \"\" reply.Type = ReduceTask reply.BucketNumber = len(c.files) c.reduceTasks[fileId] = TaskWoring return nil } // 全部提交，正常退出 if c.allCommited { reply.Type = FinishedTask return nil } // reduce 任务已经全部下发，但有的 worker 正在处理中，让 worker 闲置以防万一 reply.Type = IdleTask return nil Woker收到任务，判断任务类型执行相应操作，最后进行提交当前已完成任务，使Map任务计数器加一。 switch reply.Type { case MapTask: { MapWork(reply, mapf, workerId) } case ReduceTask: { ReduceWork(reply, reducef, workerId) } case IdleTask: { // idle 状态，此时 master 无任务可下发，并且有的 worker 正在处理中。所以啥也不干空耗时间 log.Printf(\"[client %v] idle...\", workerId) time.Sleep(500 * time.Millisecond) // idle 任务不需要 commit，直接申请下一个任务 continue } case FinishedTask: { return } } working = call(\"Coordinator.CommitTask\", \u0026commitArgs, \u0026commitReply)//提交当前任务 Worker每完成一个任务，都向Master汇报，让master进行对应处理。同样使用rpc机制实现这个通信，主要由worker向master传递信息。所以同一个worker在退出之前都会循环向Master请求任务。再一次去请求,当Map任务未全部提交时返回任务类型等待，如果全部提交，执行分配Reduce // map 任务已经全部下发，但有的 worker 正在处理中，让其他 worker 闲置等待 if c.mapCommitCount != len(c.files) { reply.Type = IdleTask return nil } Reduce... 检查所有任务提交： if c.mapCommitCount != len(c.mapTasks) || c.reduceCommitCount != len(c.reduceTasks) { return nil } c.allCommited = true log.Println(\"[server] all task commited\") return nil } 所以具体的Worker请求分为： 通过RPC在worker定义的call方法去访问Master中的公共方法 生成WorkerID 请求任务 根据返回任务类型做相应操作 操作完成提交已完成任务，更新mapCommitCount 多个Worker： 不管是测试脚本，还是我们自己跑go run，都是在模拟集群。真实运行情况下，各个worker跑在不同的机器上。我们自己跑go run或测试脚本，启动的是相互独立的进程，而不是在同一进程下启动多个线程，从而更好地模拟真实情况。创建更多worker不是在Golang代码内部实现的，而是外部启动时多次执行go run实现的。 ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:5","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"代码调试： 在运行测试代码时发现程序一直未结束，通过打印woker去请求日志可以发现，有worker一直在去请求任务但master的任务列表已经清空了 2022/04/03 16:38:22 coordinator.go:147: [server] worker 1 apply but no tasks to dispatch, let idle 2022/04/03 16:38:22 worker.go:84: [client 1] idle... 2022/04/03 16:38:23 coordinator.go:147: [server] worker 10 apply but no tasks to dispatch, let idle 2022/04/03 16:38:23 worker.go:84: [client 10] idle... 2022/04/03 16:38:23 coordinator.go:147: [server] worker 0 apply but no tasks to dispatch, let idle 2022/04/03 16:38:23 worker.go:84: [client 0] idle... 2022/04/03 16:38:23 coordinator.go:147: [server] worker 8 apply but no tasks to dispatch, let idle 2022/04/03 16:38:23 worker.go:84: [client 8] idle... 2022/04/03 16:38:23 coordinator.go:147: [server] worker 1 apply but no tasks to dispatch, let idle 2022/04/03 16:38:23 worker.go:84: [client 1] idle... 2022/04/03 16:38:23 coordinator.go:147: [server] worker 10 apply but no tasks to dispatch, let idle 2022/04/03 16:38:23 worker.go:84: [client 10] idle... 2022/04/03 16:38:23 coordinator.go:147: [server] worker 0 apply but no tasks to dispatch, let idle 2022/04/03 16:38:23 worker.go:84: [client 0] idle... 但此时打印任务提交完成的标志allCommited发现依然是false log.Printf(\"所有任务已提交: %v \\n\",c.allCommited) // 全部提交，正常退出 if c.allCommited { reply.Type = FinishedTask return nil } 查看crash.go中发现测试脚本会使你某个worker挂掉，但此时它已经申请了任务，但并未去提交任务，修改已完成的任务数。 解决办法： 每个worker进来都开启一个后台协程，处理超时的 task，如果超时就将它的任务分配标志设为未分配 ctx, _ := context.WithTimeout(context.Background(), c.timeout) go func() { select { case \u003c-ctx.Done(): { c.mutex.Lock() defer c.mutex.Unlock() // 超时后重新将 task 分配给其他 worker if c.mapTasks[fileId] != TaskCommit { c.mapTasks[fileId] = TaskFree log.Println(\"[server] timeout\", \"worker:\", args.WorkerId, \"map task:\", fileId) } } } }() 2.从日志观察多Worker任务执行过程 //为不同worker分配ID 2022/04/03 19:42:44 worker.go:61: [client 0] get a workerId 2022/04/03 19:42:44 worker.go:61: [client 1] get a workerId 2022/04/03 19:42:44 worker.go:61: [client 2] get a workerId 2022/04/03 19:42:44 worker.go:61: [client 3] get a workerId //分发任务 2022/04/03 19:42:44 coordinator.go:96: [server] dispatch map task, wokerid: 2 task file: ../pg-being_ernest.txt 2022/04/03 19:42:44 coordinator.go:96: [server] dispatch map task, wokerid: 0 task file: ../pg-dorian_gray.txt 2022/04/03 19:42:44 worker.go:73: [client 2] get a map task, filename ../pg-being_ernest.txt taskid 0 2022/04/03 19:42:44 coordinator.go:96: [server] dispatch map task, wokerid: 1 task file: ../pg-frankenstein.txt 2022/04/03 19:42:44 worker.go:73: [client 0] get a map task, filename ../pg-dorian_gray.txt taskid 1 2022/04/03 19:42:44 coordinator.go:96: [server] dispatch map task, wokerid: 3 task file: ../pg-grimm.txt 2022/04/03 19:42:44 worker.go:73: [client 1] get a map task, filename ../pg-frankenstein.txt taskid 2 2022/04/03 19:42:44 worker.go:73: [client 3] get a map task, filename ../pg-grimm.txt taskid 3 //任务提交 2022/04/03 19:42:44 coordinator.go:152: [server] worker 1 commit TaskType 0 task: 2 2022/04/03 19:42:44 coordinator.go:162: [server] map commit, workerid: 1, taskid: 2 //提交后的Master维护的任务队列 2022/04/03 19:42:44 coordinator.go:178: [server] current task stat: map [1 1 2 1 0 0 0 0] reduce [0 0 0 0 0 0 0 0 0 0] 2022/04/03 19:42:47 coordinator.go:103: [server] waiting some woking map tasks, let worker 3 idle 2022/04/03 19:42:47 worker.go:84: [client 3] idle... //4号worker执行0号Map任务超时 2022/04/03 19:43:04 coordinator.go:89: [server] timeout worker: 4 map task: 0 //将0号Map任务给再次来请求任务的3号Worker 2022/04/03 19:43:04 coordinator.go:96: [server] dispatch map task, wokerid: 3 task file: ../pg-being_ernest.txt 2022/04/03 19:43:04 coordinator.go:103: [server] waiting some woking map tasks, let worker 5 idle 2022/04/03 19:43:04 worker.go:73: [client 3] get a map task, filename ../pg-being_ernest.txt taskid 0 ","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:6","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["分布式系统"],"content":"完整代码： coordinator.go package mr import ( \"context\" \"log\" \"net\" \"net/http\" \"net/rpc\" \"os\" \"sync\" \"time\" ) type WorkerState int const ( TaskFree WorkerState = iota TaskWoring TaskCommit ) type Coordinator struct { // Your definitions here. files []string nReduce int mapTasks []WorkerState reduceTasks []WorkerState mapCommitCount int reduceCommitCount int allCommited bool timeout time.Duration mutex sync.Mutex globalWorkerId int } // Your code here -- RPC handlers for the worker to call. // // an example RPC handler. // // the RPC argument and reply types are defined in rpc.go. // func (c *Coordinator) Example(args *ExampleArgs, reply *ExampleReply) error { reply.Y = args.X + 1 return nil } func (c *Coordinator) GenWorkerId(args *GenWorkerIdArgs, reply *GenWorkerIdReply) error { c.mutex.Lock() defer c.mutex.Unlock() reply.WorkerId = c.globalWorkerId c.globalWorkerId++ log.Printf(\"[server] dispatch workerid %v\\n\", reply.WorkerId) return nil } func (c *Coordinator) ApplyTask(args *ApplyTaskArgs, reply *ApplyTaskReply) error { c.mutex.Lock() defer c.mutex.Unlock() // 延迟到 return 时执行，相当于 lock_guard // map 阶段 for fileId, fileName := range c.files { if c.mapTasks[fileId] != TaskFree { continue } reply.TaskId = fileId reply.Filename = fileName reply.Type = MapTask reply.BucketNumber = c.nReduce c.mapTasks[fileId] = TaskWoring // 后台协程，处理超时的 task ctx, _ := context.WithTimeout(context.Background(), c.timeout) go func() { select { case \u003c-ctx.Done(): { c.mutex.Lock() defer c.mutex.Unlock() // 超时后重新将 task 分配给其他 worker if c.mapTasks[fileId] != TaskCommit { c.mapTasks[fileId] = TaskFree log.Println(\"[server] timeout\", \"worker:\", args.WorkerId, \"map task:\", fileId) } } } }() // 分发完 task 就可以返回了 log.Printf(\"[server] dispatch map task, wokerid: %v task file: %v\\n\", args.WorkerId, reply.Filename) return nil } // map 任务已经全部下发，但有的 worker 正在处理中，让其他 worker 闲置等待 if c.mapCommitCount != len(c.files) { reply.Type = IdleTask log.Printf(\"[server] waiting some woking map tasks, let worker %v idle\\n\", args.WorkerId) return nil } // reduce 阶段 for fileId, taskState := range c.reduceTasks { // task already dispatched if taskState != TaskFree { continue } reply.TaskId = fileId reply.Filename = \"\" reply.Type = ReduceTask reply.BucketNumber = len(c.files) c.reduceTasks[fileId] = TaskWoring ctx, _ := context.WithTimeout(context.Background(), c.timeout) go func() { select { case \u003c-ctx.Done(): { c.mutex.Lock() defer c.mutex.Unlock() if c.reduceTasks[fileId] != TaskCommit { c.reduceTasks[fileId] = TaskFree log.Println(\"[server]:\", \"worker:\", args.WorkerId, \"reduce task:\", fileId, \"timeout\") } } } }() log.Printf(\"[server] dispatch reduce task, wokerid: %v task file: %v\\n\", args.WorkerId, reply.Filename) return nil } log.Printf(\"所有任务已提交: %v \\n\",c.allCommited) // 全部提交，正常退出 if c.allCommited { reply.Type = FinishedTask return nil } // reduce 任务已经全部下发，但有的 worker 正在处理中，让 worker 闲置以防万一 reply.Type = IdleTask log.Printf(\"[server] worker %v apply but no tasks to dispatch, let idle\", args.WorkerId) return nil } func (c *Coordinator) CommitTask(args *CommitTaskArgs, reply *CommitTaskReply) error { log.Println(\"[server] worker \", args.WorkerId, \"commit TaskType\", args.Type, \"task:\", args.TaskId) c.mutex.Lock() defer c.mutex.Unlock() switch args.Type { case MapTask: //避免重复提交 if c.mapTasks[args.TaskId] != TaskCommit { c.mapTasks[args.TaskId] = TaskCommit c.mapCommitCount++ log.Printf(\"[server] map commit, workerid: %v, taskid: %v\\n\", args.WorkerId, args.TaskId) } else { log.Printf(\"[server] map task %v commit again\\n\", args.TaskId) } case ReduceTask: if c.reduceTasks[args.TaskId] != TaskCommit { c.reduceTasks[args.TaskId] = TaskCommit c.reduceCommitCount++ log.Printf(\"[server] reduce commit, workerid: %v, taskid: %v\\n\", args.WorkerId, args.TaskId) } else { log.Printf(\"[server] reduce task %v commit again\\n\", args.TaskId) } } // c.mutex.Unlock() // 检查 all commit log.Println(\"[server] current task stat: map\", c.mapTasks, \"reduce\", c.reduceTasks) if c.mapCommitCount != len(c.mapTasks) || c.","date":"2022-05-05","objectID":"/mapreduce_lab1/:1:7","tags":["分布式系统","MIT6.824"],"title":"MapReduce_Lab1","uri":"/mapreduce_lab1/"},{"categories":["Java"],"content":"了解Java 集合.","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"集合不能直接存储基本数据类型，也不能直接存储Java对象。集合当中存储的都是Java对象的内存地址… Java 集合 ","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:0","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"一.集合概述 1.1什么是集合？ 数组是一组保存相同数据类型的集合。在某些情况下无法确定到底需要保存多少对象，由于数组的长度不可变，所以这时就不能使用数组来保存这些对象。 为了保存数目不确定的对象，Java中提供了一系列特殊的类，称为集合。集合是一个容器，可以存储任意类型的对象，并且长度可变。（所有的集合类和集合接口都在java.util包下） 1.2集合详解 集合不能直接存储基本数据类型，也不能直接存储Java对象。集合当中存储的都是Java对象的内存地址。（或者说集合中存储的是引用。） list.add(100); //自动装箱Integer 在Java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。 new ArrayList(); 创建一个集合，底层是数组。\rnew LinkedList(); 创建一个集合对象，底层是链表。\rnew TreeSet(); 创建一个集合对象，底层是二叉树。\r.....\r什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如集合中使用到的：数组、二叉树、链表、哈希表。使用不同的集合可能就是使用了不同的数据结构。 1.3集合体系核心架构图 集合框架图： 从上面的框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，称为单列集合；另一种是图（Map），存储键值对，称为双列集合。Collection 接口主要有2种子类型，List和Set ，而List和Set下面又有一些实现类。常用的集合有 ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： **接口：**是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象。 **实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap等。 **算法：**是实现集合接口的对象里的方法执行的一些有用的计算。例如：搜索和排序。 ","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:1","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"二.List集合 2.1 Collection接口简介 Collection 接口是最基本的集合接口，一个 Collection 代表一组 Object， Java不提供直接继承自Collection的类，只提供继承于Collection的子接口(如List和set)。 由于 Collection 是所有单列集合的根接口，所以Collection中定义的一些方法，可以用于操作所有的单列集合。 Collection接口的常用方法： boolean add(E e)：添加一个元素 void clear()：清空集合中所有的元素 boolean remove(E e)：移除集合中指定的元素 boolean contains(E e)：检查集合中是否包含指定的对象 boolean isEmpty()：判断集合是否为空 int size()：获取数组的大小 Object[] toArray()：把集合元素存储到数组中 Iterator iterator():返回在该集合上进行迭代的迭代器，用于遍历该集合所有元素 public class CollectionTest01 { public static void main(String[] args) { Collection c = new ArrayList(); //向集合种添加元素 c.add(\"4123\"); c.add(\"1456\"); c.add(\"3789\"); //获取集合中元素的个数 System.out.println(\"元素个数是：\"+c.size());//元素个数是：3 //判断集合中是否包含某个元素 c.add(\"jack\"); c.add(235);//这里有一个自动装箱的问题 boolean flag1 = c.contains(\"4123\"); System.out.println(flag1);//true boolean flag2 = c.contains(123); System.out.println(flag2);//false //删除集合中的某个元素 c.remove(\"1456\"); System.out.println(\"元素个数是：\"+c.size());//元素个数是：4 //判断集合是否为空 System.out.println(c.isEmpty());//false //清空集合所有元素 c.clear(); System.out.println(c.isEmpty());//true System.out.println(\"元素个数是：\"+c.size());//元素个数是：0 //添加元素 c.add(\"s1\"); c.add(\"s2\"); c.add(\"s3\"); c.add(\"s4\"); c.add(\"s5\"); c.add(new Student()); //把集合转化成数组 Object[] objs = c.toArray(); for (int i = 0;i\u003cobjs.length;i++){ //遍历数组 Object o = objs[i]; System.out.println(o); } } } class Student{ } contains()和remove()方法深入：在上面例子中，调用contains方法，输出结果是对的，那么如果调用的是自定义类呢？ public class CollectionTest05 { public static void main(String[] args) { //创建集合对象 Collection c = new ArrayList(); User u1 = new User(\"jack\"); c.add(u1); User u2 = new User(\"jack\"); //判断集合中是否包含u2 //没重写equals方法之前 // System.out.println(c.contains(u2));//结果为：false System.out.println(c.contains(u2));//结果为：true //重写equals方法后删除u2 c.remove(u2); System.out.println(\"元素个数是：\"+c.size());//元素个数是：0 //由此可见，remove和contains调用equals方法是相同的 } } class User{ private String name; public User() { } public User(String name) { this.name = name; } //重写equals方法 public boolean equals(Object o){ //传入对象为null或者对象类型不是User if (o == null || !(o instanceof User)) return false; if (o == this) return true; User u = (User)o; //如果名字一样表示同一个人。不再比较对象的内存地址，这里比较的是内容 return u.name.equals(this.name); } } 在集合中，对于contains()方法，底层调用了euqals()方法比较内容，不需要重写equals()方法。但是对于自定义类，类中没有重写equals()方法，默认继承的是Object的equals()方法，所以没重写时输出结果为“false”。 因此，对于自定义类，调用contains()方法和remove()方法之前必须重写equals()方法。 2.2 List接口简介 List 接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，通过索引(元素在 List 中的位置，类似于数组的下标)可以访问 List 中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 List接口的特点：有序可重复，存储的元素有下标。有序是因为List集合都有下标，以1递增，可以通过索引来访问集合中的元素。 List接口继承自Collection接口，所有Collection接口的方法，List都可以使用，并且List中还新增了一些操作集合的特有方法。 List集合常用方法（在Collection基础上）： void add(int index,E element) 在列表的指定位置插入指定元素。 Object get(int index) 返回列表中指定索引位置的元素。 int hashCode() 返回列表的哈希码值。 Object remove(int index) 移除列表中指定位置的元素 Object set(int index,Object element) 用指定元素替换列表中指定位置的元素。 int indexOf(Object o) 返回列表中首次出现指定元素的索引，如果列表不包含此元素，则返回-1。 int lastIndexOf(Object o) 返回列表中最后出现指定元素的索引，如果列表不包含此元素，则返回-1。 Object[] toArray() 返回以正确顺序包含列表中的所有元素的数组。 public class ListTest01 { public static void main(String[] args) { //创建List类型的集合 List list = new ArrayList(); //添加元素 list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); //在索引位置为1的位置上添加“king“，索引从0开始，第一个参数是下标 list.add(1,\"King\"); //通过下标获取元素 System.out.println(\"下标为3处的元素是：\"+list.get(3)); //获取指定对象第一次出现的索引 System.out.println(\"B第一次出现的索引是：\"+list.indexOf(\"B\")); //获取指定对象最后一次出现的索引 list.add(4,\"B\"); System.out.println(\"B最后一次出现的索引是：\"+list.lastIndexOf(\"B\")); //删除指定位置处的元素 System.out.println(\"元素个数是：\"+list.size()); list.remove(0); System.out.println(\"元素个数是：\"+list.size()); //修改指定位置处的元素,list.set(indexOf,element); list.set(3,100); System.out.println(\"========================\"); //通过下标遍历元素：因为list集合有自己的特点：有索引。 for (int i = 0;i\u003clist.size();i++){ Object o = list.get(i); System.out.println(o); } } } 2.3 ArrayList集合 ArrayList是List接口中的一个实现类，是程序中最常见的一种接口，底层是数组。 数组的优点：检索效率高。 数组的缺点：随机增删元素的效率低，并且不适合大数据存储 ArrayList集合的优点：把检索发挥到极致，并且给末尾添加元素的效率很高。 ArrayList集合有一个初始容","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:2","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"三.Set集合 3.1 Set集合简介 Set 集合具有与 Collection 完全一样的接口，只是行为上不同，Set接口中的元素无序，并且存入Set的每个元素都必须是唯一的。 Set集合主要有两个实现类：HashSet和TreeSet。 3.2 HashSet集合 HashSet底层数据结构采用哈希表，元素无序不可重复，非线程安全，效率高。 HashSet底层通过包装HashMap来实现，HashSet在添加一个值的时候，实际上是将此值作为HashMap中的key来进行保存。 可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。 具体实现唯一性的比较过程： 当调用HashSet集合的add()方法时，首先会使用hashCode()方法获取对象的哈希值，然后根据对象的哈希值计算出一个存储位置；如果该存储位置上没有元素，则直接将元素存入，如果该位置上有元素存在，则会调用euqals()方法让当前存入的元素一一和该元素进行比较。如果返回结果为false就将该元素存入集合；返回结果为true则说明有重复元素，就将该元素舍弃。 Set实现类的集合对象中不能有重复元素，HashSet也一样，它是用了hash算法来保证其中的元素不重复。初始化容量16，默认加载因子0.75。 当向集合中存入元素时，为了保证HashSet正常工作，要求存入对象时，需要重写equals()方法和hashCode()方法。如果是String或者Integer这类Java已经写好了的常用类，就不用重写这两个方法，因为它们已经默认重写了。所以当存储的元素为自定义类对象时，必须重写hashCode()方法和equals()方法。 例子： public class HashSetTest02 { public static void main(String[] args) { HashSet hs = new HashSet(); Postgraduate p1 = new Postgraduate(1,\"jack\"); Postgraduate p2 = new Postgraduate(2,\"lisa\"); Postgraduate p3 = new Postgraduate(2,\"lisa\"); hs.add(p1); hs.add(p2); hs.add(p3); System.out.println(hs); } } //研究生类 class Postgraduate{ int id; String name; public Postgraduate(int id, String name) { this.id = id; this.name = name; } @Override public String toString() { return id +\":\"+name; } } 存入三个对象，由于没有重写equals()方法和hashCode()方法，所以即使在id和name相同的情况下，集合也会认为p2和p3是两个不同的对象，因为p2和p3的引用地址不同。下面对equals()方法和hashCode()方法进行重写: //重写equals方法和hashcode方法 @Override public boolean equals(Object o) { //地址相同返回true if (this == o) return true; //判断对象是不是Postgraduate类 if (o == null ||!(o instanceof Postgraduate)) return false; Postgraduate that = (Postgraduate) o; //id相同并且name相同返回true return this.id == that.id \u0026\u0026 this.name.equals(that.name); } @Override public int hashCode() { return Objects.hash(id, name); } Postgraduate类重写了Object类中的equals()方法和hashCode()方法。在hashCode()中返回id属性的hash值，在equals()方法中比较对象的id是否相等，并返回结果。当调用返回HashSet集合中的add()方法添加p3元素时，发现它的哈希值与p2的哈希值相同，而且调用equals()方法返回true，HashSet集合认为两个对象相同，重复的对象p3就会被舍弃。 3.3 TreeSet集合 TreeSet集合底层实际上是一个TreeMap，而TreeMap集合底层是一个二叉树，放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。元素唯一且已经排好序；二叉树结构保证了元素的有序性。 TreeSet集合中的元素特点：无序不可重复。但是可以按照元素的大小顺序自动排序。称为：可排序集合。 二叉树就是每个节点最多只有两个节点的有序树，每个节点及其子节点组成的树成为子树，左侧子节点称为左子树，右侧子节点称为右子树，左子树节点小于根结点，右侧子节点大于根结点。 例如：13，8，17，17，1，11，15，25的存储过程： 同一层元素，左边的元素总是小于右边的元素。当二叉树中存入新元素时，新元素首先会与第一个元素（最顶层元素）进行比较，如果小于第一个元素就执行左边的分支，继续和该分支的子元素进行比较，如果大于第一个元素就执行右边的分支，继续和该分支的子元素进行比较，直到最后。取出的时候TreeSet集合和TreeMap集合都是按照“左根右“的方式来取的。 TreeSet集合中的特有方法： Object first（） 返回TreeSet集合的首个元素 Object last（） 返回TreeSet集合的最后一个元素 Object lower（Object o）返回TreeSet集合中小于给定元素的最大元素，如果没有就返回null Object floor（Object o）返回TreeSet集合中小于或等于给定元素的最大元素，如果没有就返回null Object higher（Object o）返回TreeSet集合中大于给定元素的最小元素，如果没有就返回null Object ceiling（Object o）返回TreeSet集合中大于或等于给定元素的最小元素，如果没有就返回null Object pollFirst（）移除并返回集合的第一个元素 Object pollLast（）移除并返回集合的最后一个元素 public class TreeSetTest01 { public static void main(String[] args) { TreeSet ts = new TreeSet(); ts.add(8); ts.add(4); ts.add(9); ts.add(14); ts.add(1); //获取首尾元素 System.out.println(\"首元素：\"+ts.first()); System.out.println(\"尾元素：\"+ts.last()); //比较并获取元素 System.out.println(\"\u003c=7的元素：\"+ts.floor(7)); System.out.println(\"\u003e8的元素：\"+ts.higher(8)); //删除元素 Object obj = ts.pollFirst(); System.out.println(\"删除的第一个元素是：\"+obj); } } public class TreeSetTest02 { //这个时候可以使用TreeSet集合，因为TreeSet集合放进去，拿出来是有顺序的 public static void main(String[] args) { TreeSet\u003cString\u003e ts = new TreeSet\u003c\u003e(); //添加元素 ts.add(\"zhangsan\"); ts.add(\"lisi\"); ts.add(\"wangwu\"); ts.add(\"zhaoliu\"); //遍历 for (String s:ts) { System.out.println(s); } //输出结果： // lisi // wangwu // zhangsan // zhaoliu System.out.println(\"-----------------------------\"); TreeSet\u003cInteger\u003e ts2 = new TreeSet\u003c\u003e(); ts2.add(10); ts2.add(3); ts2.add(7); ts2.add(1); for (Integer s1:ts2){ System.out.println(s1); } //输出结果： //1 //3 //7 //10 } } 在实际开发中，除了会向TreeSet集中存储一些Java中默认的类型数据外，还会存储一些用户自定义的类型数据。由于这些自定义类型的数据没有实现Comparable接口，因此无法直接在TreeSet集合中进行排序操作。 TreeSet的两种排序规则：自然排序、定制排序。默认情况下，TreeSet是自然排序。自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列；定制排序要在TreeSet","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:3","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"四.Map集合 4.1Map集合简介 如果想存储具有对应关系的数据，需要使用Map接口。Map用于保存具有映射关系的数据，是一种双列接口，Map里保存着两组数据：key和value，它们可以是任何引用类型的数据，但key不能重复。通过指定的key就可以取出对应的value。（value可以重复） 注意： Map 没有继承 Collection 接口， Map 提供 key 到 value 的映射，可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 。 Map常用方法： V put(K key, V value) 向Map集合中添加键值对 V get(Object key) 通过key获取value void clear() 清空Map集合 boolean containsKey(Object key) 判断Map中是否包含某个key boolean containsValue(Object value) 判断Map中是否包含某个value boolean isEmpty() 判断Map集合中元素个数是否为0 V remove(Object key) 通过key删除键值对 int size() 获取Map集合中键值对的个数。 Collection\u003cV\u003e values() 获取Map集合中所有的value，返回一个Collection Set\u003cK\u003e keySet() 获取Map集合所有的key（所有的键是一个set集合） Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet() 将Map集合转换成Set集合 public class MapTest01 { public static void main(String[] args) { //创建Map集合对象 Map\u003cInteger,String\u003e map = new HashMap\u003c\u003e(); //向Map集合中添加键值对 map.put(1,\"zhangsan\"); map.put(2,\"lisi\"); map.put(3,\"wangwu\"); map.put(4,\"zhaozixu\"); //通过key值获取value String value = map.get(2); System.out.println(value); //获取键值对的数量 System.out.println(\"键值对的数量：\"+map.size()); //通过key删除键值对 map.remove(4); System.out.println(\"键值对的数量：\"+map.size()); //判断是否包含某个key、value //contains方法底层调用的都是equals进行对比的，所以自定义类型的需要重写equals方法 System.out.println(map.containsKey(4)); System.out.println(map.containsValue(\"lisi\")); //获取所有的value Collection\u003cString\u003e values = map.values(); for (String s:values) { System.out.println(s); } //清空map集合 map.clear(); System.out.println(\"键值对数量：\"+map.size()); System.out.println(map.isEmpty()); } } lisi 键值对的数量：4 键值对的数量：3 false true zhangsan lisi wangwu 键值对数量：0 true 4.2 HashMap集合 HashMap 是一个最常用的Map,它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度 HashMap最多只允许有一条记录的键为Null，但是允许多条记录的值为 Null HashMap非线程安全 HashMap底层是由哈希表结构组成的，是”数组+链表“的组合体，通过初始化一个Entry数组来实现key、value的保存。数组是HashMap的主体结构。HashMap将两种数据结构的优点融合起来，对于元素的增、删、改、查操作表现出的效率都比较高。HahMap的key值无序不可重复。初始容量为16，默认加载因子是0.75。 水平方向以数组结构为主体并在竖直方向以链表结构进行结合的就是HashMap中的哈希表结构。水平方向数组的长度称为HashMap集合的容量，竖直方向上每个元素对应的链表结构称为一个桶，每个桶的位置在集合中都有对应的桶值，用于快速定位集合添加、查找。 HashMap的put()方法实现原理 当向HashMap集合添加元素时，首先会调用键对象k的hash(k)方法，快速定位并寻址到该元素在集合中要存储的位置。在定位到存储元素键对象k的哈希值所对应桶位置后，会出现两种情况:第一 种情况，键对象k的hash值所在桶位置为空，则可以直接向该桶位置插入元素对象；第二种情况，键对象k的hash值所在桶位置不为空，则还需要继续通过键对象k的equals(k)方法比较新插人的元素键对象k和已存在的所有元素键对象k是否相同，如果键对象k相同，就会对原有元素的值对象v进行替换并返回原来的旧值，否则会在该桶的链表结构头部新增一个节点来插人新的元素对象。 HashMap集合的key会先后调用两个方法，一个方法是hashCode()，一个方法是equals()，所以在自定义类中这两个方法都要重写。 HashMap的get()方法实现原理 调用k的hashCode()方法得出哈希值，通过哈希算法转换成数组下标，通过数组下标定位到某个位置，如果这个位置上什么也没有，返回null；如果有单向链表，那么会拿着参数k和单向链表上的每个节点中的k进行equals()比较，如果所有的equals()方法都返回false，那么get方法返回null，只要其中有一个节点的k和参数 k 进行equals()比较的时候返回true，那么此时这个节点的value就是要找的value，get()方法最终返回这个值。 public class HashMapTest01 { public static void main(String[] args) { //测试HashMap集合key集合部分的元素特点 //Integer是key，它的hashcode和equals都重写了 Map\u003cInteger,String\u003e map = new HashMap\u003c\u003e(); map.put(1,\"zhangsan\"); map.put(2,\"lisi\"); map.put(3,\"wangwu\"); map.put(4,\"zhaoliu\"); map.put(2,\"liuqi\");//后面一个2的value会覆盖前面2中的值 System.out.println(map.size()); //遍历map集合 Set\u003cMap.Entry\u003cInteger,String\u003e\u003e set = map.entrySet(); for (Map.Entry\u003cInteger,String \u003e node:set){ System.out.println(node.getKey()+\"=\"+node.getValue()); } } } 自定义类： public class HashMapTest02 { public static void main(String[] args) { Student s1 = new Student(\"zhangsan\"); Student s2 = new Student(\"zhangsan\"); //重写equals方法之前是false //System.out.println(s1.equals(s2)); //重写equals方法之后是true System.out.println(s1.equals(s2)); //调用Object中的hashcode方法，未重写 System.out.println(\"s1的hashcode：\"+s1.hashCode()); System.out.println(\"s2的hashcode：\"+s2.hashCode()); //s1.equals(s2)的结果是true，表示s1和s2是一样的，王Hash Set集合中放，应该只能放进去yi Set\u003cStudent\u003e students = new HashSet\u003c\u003e(); students.add(s1); students.add(s2); //System.out.println(students.size());//结果应该是1，而不是现在输出的2 System.out.println(students.size());//重写之后，输出为1 } } public class Student { private String name; public Student() { } public Student(String name) { this.name = name; } //重写equals方法 @Override public boolean equals(Object obj) { if (obj == null ||!(obj instanceof Student)) return false; if (obj == this) return true; Student s = (Stude","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:4","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"五. Collections 工具类 专门用来操作集合的类称为Collections，Collections类中提供了大量的静态方法用于对集合中元素进行排序、查找和修改等操作。 常用方法： reverse(List list) 反转指定List集合中元素的顺序 shuffle(List list) 对List中的元素进行随机排序（洗牌） sort(List list) 对List里的元素根据自然升序排序 sort(List list, Comparator c) 自定义比较器进行排序 swap(List list, int i, int j) 将指定List集合中i处元素和j出元素进行交换 rotate(List list, int distance) 将所有元素向右移位指定长度，如果distance等于size那么结果不变 binarySearch(List list, Object key) 使用二分搜索法，以获得指定对象在List中的索引，前提是集合已经排序 max(Collection coll) 返回最大元素 max(Collection coll, Comparator comp) 根据自定义比较器，返回最大元素 min(Collection coll)：返回最小元素 min(Collection coll, Comparator comp) 根据自定义比较器，返回最小元素 fill(List list, Object obj) 使用指定对象填充 frequency(Collection Object o) 返回指定集合中指定对象出现的次数 replaceAll(List list, Object old, Object new) 替换 复制代码 public class CollectionsTest02 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); //将所有指定元素添加到指定集合中 Collections.addAll(list,\"h\",\"f\",\"l\",\"a\",\"y\"); System.out.println(\"排序前：\"+list); //反转集合 Collections.reverse(list); System.out.println(\"反转后：\"+list); //按自然顺序排列 Collections.sort(list); System.out.println(\"按自然顺序排列后：\"+list); //随机排序 Collections.shuffle(list); System.out.println(\"随机排序：\"+list); //将角标i处元素和角标j处元素交换 Collections.swap(list,0,list.size()-1); System.out.println(\"交换后：\"+list); } } ","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:5","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"总结 Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 总结： （1）常用方法 （2）自定义类的方法重写 （3）集合遍历 ","date":"2022-04-20","objectID":"/java%E9%9B%86%E5%90%88/:0:6","tags":["Java","集合"],"title":"Java集合","uri":"/java%E9%9B%86%E5%90%88/"},{"categories":["Java"],"content":"Stream中的并行与并发.","date":"2022-04-18","objectID":"/stream%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/","tags":["Java","Stream","JUC"],"title":"Stream中的并行与并发","uri":"/stream%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["Java"],"content":"并发的实质是同一个物理CPU上在若干个程序（线程）之间的多路复用，是强制有限的物理资源行使多用户共享来提高效率。而并行则是让多道程序（线程）在同一时刻不同的CPU上运行. 并行与并发 并行与并发 ​ 并发与并行是两个相似又不同的概念： ​ 并发：多个任务可以在重叠的时间段内运行。 ​ 并行：多个任务可以同时运行。 ​ 并发的实质是同一个物理CPU上在若干个程序（线程）之间的多路复用，是强制有限的物理资源行使多用户共享来提高效率。而并行则是让多道程序（线程）在同一时刻不同的CPU上运行。从宏观上看，它们都使得线程可以同时运行，但实际上只有并行是真正的同时运行的。 ​ 因此，并行、并发与多线程的关系就是： ​ 并行需要两个或两个以上的线程跑在不同的处理器上，并发可以跑在⼀个处理器上通过时间片进行切换。 ​ 也就是说，我们的处理器只要不是单核的，就具有并行运行的能力。 ParallelStream并行流的创建 ​ JAVA8中引入了lamda表达式和Stream接口。其丰富的API及强大的表达能力极大的简化代码，提升了效率，同时还通过parallelStream提供并发操作的支持，本文探讨parallelStream方法的使用。 ​ ParadellelStream可以帮助我们创建并行流，这些并行流默认是基于Fork/Join框架运行的，也就是说，它们运行在ForkJoin线程池中。Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。在多数场景以及默认情况使用时，我们一般直接使用 ForkJoinPool 中的common池。 并行流的创建 ​ 我们可以使用parallel()方法将一个流转换为并行流，也可以直接使用parallelStream将一个数据集合转换为并行流。 ​ parallel方法是BaseStream接口实现的，而继承这个接口的有LongStream、IntStream、DoubleStream、Stream等。parallelStream是Collection接口的方法，用于把实现了Collection接口的集合转换为并行流。 ​ 在以下的代码中，我们使用BaseStream的另一个方法isParallel来判断一个流是否为并行流。注意，这个方法并不是终止操作，它只是于判断流的状态的一个方法。 @Test public void parallelStreamOf(){ System.out.println(Stream.of(3,1,4,1,5,9).parallel().isParallel()); } @Test public void parallelStreamIterater(){ System.out.println(Stream.iterate(1,n-\u003en+1).parallel().isParallel()); } @Test public void parallelStreamInt(){ System.out.println(IntStream.rangeClosed(0,250).parallel().isParallel()); } @Test public void parallelStreamMethodOnCollection(){ List\u003cInteger\u003e numbers = Arrays.asList(1,2,3,4,5,6,7); System.out.println(numbers.parallelStream().isParallel()); } @Test public void parallelStreamMethodOnCollection(){ List\u003cInteger\u003e numbers = Arrays.asList(1,2,3,4,5,6,7,1,4,3); System.out.println(numbers.parallelStream().isParallel()); Set\u003cInteger\u003e set = numbers.stream().collect(Collectors.toSet()); System.out.println(set.parallelStream().isParallel()); set.parallelStream().forEach(System.out::println); } ​ 从上面的代码中我们可以注意到，我们使用了parallel()方法将一个顺序流转换成了一个并行流。那么我们也可以调用BaseStream接口的sequential()方法将一个并行流转换为顺序流。 @Test public void parallelStreamThensequential(){ List\u003cInteger\u003e numbers = Arrays.asList(1,2,3,4,5,6,7); System.out.println(numbers.parallelStream().sequential().isParallel()); } ​ 那么，我们可以不可以在同一个流中既运行并行流，又运行顺序流呢？ //我们发现这段程序的所有流任务都是在main线程中运行的 @Test public void parallelStreamThensequential1(){ List\u003cInteger\u003e numbers = Arrays.asList(1,2,3,4,5,6,7); numbers.parallelStream().map(m -\u003e { System.out.println(Thread.currentThread().getName()); return m; }).sequential().sorted().collect(Collectors.toList()); } //打印结果为不同的线程 @Test public void parallelStreamThensequential12(){ List\u003cInteger\u003e numbers = Arrays.asList(1,2,3,4,5,6,7); numbers.parallelStream().map(m -\u003e { System.out.println(Thread.currentThread().getName()); return m; }).sequential().sorted().parallel().collect(Collectors.toList()); } ​ 从上面的代码的运行结果来看，答案是否定的。也就是说，一个流要么是并行流，要么是顺序流。这是因为流在到达终止操作之前不会进行任何操作，只有当到达终止操作之后才会评估流的状态。如果在终止操作前最后调用的是sequential()方法，那么这个流将是一个顺序流。同理，如果是parallel()方法最后调用，那么这个流将是一个并行流。当我们需要同时在一段操作任务中使用到并行流和顺序流时，除了使用两个流，暂时没有更好的解决办法。 @Test public void parallelStreamThensequential2(){ List\u003cInteger\u003e numbers = Arrays.asList(1,2,3,4,5,6,7); numbers.parallelStream() .map(m -\u003e { System.out.println(Thread.currentThread().getName()); return m; }).collect(Collectors.toList()) .stream() .sequential() .sorted() .map(m -\u003e { System.out.println(Thread.currentThread().getName()); return m; }).collect(Collectors.toList()); } 并行流的运行特点 并行流对于中间操作和终止操作运行结果的影响 ​ 由于CPU核心的运行速度有差异，并行流对中间操作可能存在执行结时在先后顺序上的影响，比如说输出的顺序和源数据的顺序差异。并行流对于ForEach终止操作也有类似的影响。但对于收集操作，例如collect()、max()等，并行流并未对结果造成影响。对于短路操作而言，可能在运行时间上有细微差异，其它的影响也几乎没有。 ​ 并行流将一个大任务分成多个小任务，这些小任务并行执行，最终到达终止操作，等所有任务到达终止操作之后，返回结果。理论上会加快运行速度。 @Test public void parallelStreamsetForkJoinPooltwo(){ Instant before = Instant.now(); // int total = IntStream.of(3,1,4,1,5,9).map(ParallelStreamTest::doubleIt).sum(); // int total = IntStream.of(3,1,4,1,5,9).parallel().map(ParallelStreamTest::doubleIt).sum(); // int total = IntStream.rangeClosed(0,250).parallel().map(ParallelStreamTest::doubleIt).sum(); Instant after = Instant.now(); Durati","date":"2022-04-18","objectID":"/stream%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/:0:0","tags":["Java","Stream","JUC"],"title":"Stream中的并行与并发","uri":"/stream%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["Java"],"content":"了解java泛型.","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用.. java 泛型详解 1. 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 泛型是在java 1.5 引入的，随着java 8 的兴起，变得更为复杂。 什么是泛型？为什么要使用泛型？ 泛型实质就是一个类型占位符 泛型，即“参数化类型”。最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。 那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型换成变量类型--参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 2. 一个实例及泛型属性 我们每天都在使用泛型！ 泛型只能是引用类型！ List\u003cString\u003e arrayList = new ArrayList\u003cString\u003e(); List\u003cInteger\u003e arrayList1 = new ArrayList\u003cInteger\u003e(); ... //实例化时，只能接收一具体类型--引用类型 //arrayList.add(100); 在编译阶段，编译器就会报错 注： 引入泛型的这个运算符\u003c\u003e称之为 （diamond operator）–钻石运算符 泛型只在编译阶段有效。看下面的代码： List\u003cString\u003e stringArrayList = new ArrayList\u003cString\u003e(); List\u003cInteger\u003e integerArrayList = new ArrayList\u003cInteger\u003e(); Class classStringArrayList = stringArrayList.getClass(); Class classIntegerArrayList = integerArrayList.getClass(); if(classStringArrayList.equals(classIntegerArrayList)){ Log.d(\"泛型测试\",\"类型相同\"); } zzs注：以上其实是一个类对象！具有相同的属性以及方法签名！ 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 Java 泛型擦除（类型擦除）是指在编译器处理带泛型定义的类、接口或方法时，会在字节码指令集里抹去全部泛型类型信息，泛型被擦除后在字节码里只保留泛型的原始类型（raw type）。 原始类型是指抹去泛型信息后的类型，在 Java 语言中，它必须是一个引用类型（非基本数据类型），一般而言，它对应的是泛型的定义上界。 示例： 中的 T 对应的原始泛型是 Object， 对应的原始类型就是 String。 3. 泛型的使用 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:0:0","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.1 泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（下面的例子中详解）： class 类名称 \u003c泛型标识：可以随便写任意标识号，标识指定的泛型的类型\u003e{ private 泛型标识 /*（成员变量类型）*/ var; ..... } } 一个最普通的泛型类： //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic\u003cT\u003e{ //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; } } //泛型的类型参数只能是引用类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic\u003cInteger\u003e genericInteger = new Generic\u003cInteger\u003e(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic\u003cString\u003e genericString = new Generic\u003cString\u003e(\"key_vlaue\"); Log.d(\"泛型测试\",\"key is \" + genericInteger.getKey()); Log.d(\"泛型测试\",\"key is \" + genericString.getKey()); 12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456 12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue 定义的泛型类，就一定要传入泛型类型实参么？ 并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入特定的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。 如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。但很少有使用价值，不建议！ 看一个例子： Generic generic = new Generic(\"111111\"); Generic generic1 = new Generic(4444); Generic generic2 = new Generic(55.55); Generic generic3 = new Generic(false); Log.d(\"泛型测试\",\"key is \" + generic.getKey()); Log.d(\"泛型测试\",\"key is \" + generic1.getKey()); Log.d(\"泛型测试\",\"key is \" + generic2.getKey()); Log.d(\"泛型测试\",\"key is \" + generic3.getKey()); D/泛型测试: key is 111111 D/泛型测试: key is 4444 D/泛型测试: key is 55.55 D/泛型测试: key is false 注意： 泛型的类型参数只能是引用类型，不能是简单类型。（8种数据类型）.Java以后考虑加入!但也是进行封装自动装拆箱的操作！ 不能对不确切的泛型类型使用 instanceof 操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic){ } ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:1:0","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.2 泛型接口 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： //定义一个泛型接口 public interface Generator\u003cT\u003e { public T next(); } 当实现泛型接口的类，未传入泛型实参时： 此时与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。 /** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator\u003cT\u003e implements Generator\u003cT\u003e{ * 如果不声明泛型，如：class FruitGenerator implements Generator\u003cT\u003e，编译器会报错：\"Unknown class\" */ class FruitGenerator\u003cT\u003e implements Generator\u003cT\u003e{ @Override public T next() { return null; } } 当实现泛型接口的类，传入泛型实参时： 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 /** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator\u003cT\u003e * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator\u003cT\u003e，public T next();中的的T都要替换成传入的String类型。 */ public class FruitGenerator implements Generator\u003cString\u003e { private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"}; @Override public String next() { Random rand = new Random(); return fruits[rand.nextInt(3)]; } } ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:2:0","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.3 泛型方法 在java中,泛型类的定义非常简单，但是泛型方法却略为复杂。 尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。 泛型类，是在实例化类的时候指明泛型的具体类型； 泛型方法，是在调用方法的时候指明泛型的具体类型 。 /** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间\u003cT\u003e是必要的，可以理解为：声明此方法为泛型方法。 * 2）只有使用钻石运算符，声明了\u003cT\u003e的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）\u003cT\u003e表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */ public \u003cT\u003e T genericMethod(Class\u003cT\u003e tClass) throws InstantiationException , IllegalAccessException{ T instance = tClass.newInstance(); return instance; } 具体调用： Object obj = genericMethod(Class.forName(\"com.test.test\")); 如何理解泛型方法的签名格式： 一个泛型方法定义实例： static \u003cT extends Object \u0026 Comparable\u003c? super T\u003e\u003e T max(Collection\u003c? extends T\u003e collection) T的理解： 1、T是有界的。 它既Object或是是Object的子类，又需要实现了Comparable接口。Comparable定义为T或T的任何父类。（Object是类，必须放于首位）！ 2、max方法的参数为一个集合Collection实例，它的元素需要是T或T的任何子类的Collection. 3、该方法返回T类型。 譬如Integer， String都是可以的。 因为第一条显然满足。 第二条：List、 Set等都是Collection, List, Set等都满足条件。List, Set的实例对象都可以作为参数传入。 ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:0","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.3.1 泛型方法的基本用法 我们再通过一个例子，把泛型方法再总结一下: public class GenericTest { //这个类是个泛型类，在上面已经介绍过 public class Generic\u003cT\u003e{ private T key; public Generic(T key) { this.key = key; } //其实这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey(){ return key; } /** * 下面这个方法显然是有问题的，在编译器会给我们提示这样的错误信息\"cannot reslove symbol E\" * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key){ this.key = keu } */ } /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的\u003cT\u003e必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public \u003cT,K\u003e K showKeyName(Generic\u003cT\u003e container){ * ... * } */ public \u003cT\u003e T showKeyName(Generic\u003cT\u003e container){ System.out.println(\"container key :\" + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; } //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic\u003cNumber\u003e这个泛型类做形参而已。 public void showKeyValue1(Generic\u003cNumber\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic\u003c?\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } /** * 这个方法是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'E' \" * 虽然我们声明了\u003cT\u003e,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public \u003cT\u003e T showKeyName(Generic\u003cE\u003e container){ ... } */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'T' \" * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj){ } */ } ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:1","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.3.2 类中的泛型方法 泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下 public class GenericFruit { class Fruit{ @Override public String toString() { return \"fruit\"; } } class Apple extends Fruit{ @Override public String toString() { return \"apple\"; } } class Person{ @Override public String toString() { return \"Person\"; } } class GenerateTest\u003cT\u003e{ public void show_1(T t){ System.out.println(t.toString()); } //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型\u003cE\u003e，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public \u003cE\u003e void show_3(E e){ System.out.println(e.toString()); } //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public \u003cT\u003e void show_2(T t){ System.out.println(t.toString()); } } public static void main(String[] args) { Apple apple = new Apple(); Person person = new Person(); GenerateTest\u003cFruit\u003e generateTest = new GenerateTest\u003cFruit\u003e(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); } } ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:2","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.3.3 泛型方法与可变参数 再看一个泛型方法和可变参数的例子： public \u003cT\u003e void printMsg( T... args){ for(T t : args){ System.out.println( \"泛型测试 ----\u003et is \" + t ); System.out.println( (t instanceof String) ); //zzs 注：看是否字符串 } } printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:3","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.3.4 静态方法与泛型 静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型，因为实例化后才会给泛型赋具体的类型； 如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 public class StaticGenerator\u003cT\u003e { .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t){..},此时编译器会提示错误信息： \"StaticGenerator cannot be refrenced from static context\" */ public static \u003cT\u003e void show(T t){ } } ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:4","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.3.5 泛型方法总结 泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则： 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:5","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.4 泛型通配符与PECS 通配符是一种使用（？）的类型参量, 可能存在或也可能不存在上界或下界！ 在使用泛型的时候，可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 public void showKeyValue1(Generic\u003c? extends Number\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } Generic\u003cString\u003e generic1 = new Generic\u003cString\u003e(\"11111\"); Generic\u003cInteger\u003e generic2 = new Generic\u003cInteger\u003e(2222); Generic\u003cFloat\u003e generic3 = new Generic\u003cFloat\u003e(2.4f); Generic\u003cDouble\u003e generic4 = new Generic\u003cDouble\u003e(2.56); //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类 //showKeyValue1(generic1); showKeyValue1(generic2); showKeyValue1(generic3); showKeyValue1(generic4); 如果我们把泛型类的定义也改一下: 就可以限定泛型类实例化的类型了。如： public class Generic\u003cT extends Number\u003e{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; } } 1、无界通配符具有局限性，譬如： List\u003c?\u003e list = new ArrayList\u003c\u003e(); 无法添加元素。但可以读去元素。 最大用途：无界List 所有传入List\u003c?\u003e作为参数的方法（Consummer）会在调用时接收任意列表！如： private static void printList(List\u003c?\u003e list){ System.out,println(list); } 2、问号是设置类型边界的利器，用法可以灵活多样化！ 上界通配符（upper bounded wildcard）：父类定死了，所以称为上界！ 使用关键词 extends, 如： List\u003c? extends Comparable\u003e //表示实参只能接收实现了comparable接口的类或其子类！ 注意：extends 之后可以是接口！ 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。是一种真实的类型。如： List\u003c? extends Number\u003e numbers = new ArrayList\u003c\u003e(); //numbrs.add(3); //是无法添加值的！原因是编译器并不知道其具体类型！ //但可以作为方法定义。使用时再设置具体的类型！ 我们通过定义上界指定变量必须符合的类型，以便方法实现能够正常工作。譬如：以上需要对数字求和时，只有Number及子类才具有求和的方法！ 下界通配符（lower bounded wildcard）：子类定死了，所以称为下界！ 使用关键词 super, 如： private static int mylist(List\u003c? super Number\u003e) //可以是Number，Object List\u003c? super Integer\u003e 中， List、List、List都符合要求。 使用以上下界通配符一位着列表用于存储整数，但方法允许在任何超类中的列表中使用引用。 PECS原则：（Producer Extends，Consumer Super） 如果泛型（参数化类型）代表的是生产者（producer）则使用extends，如果代表消费者（consumer）则使用super！如果同时代表两者，则无需使用通配符！ 从泛型代表的数据体对象获取（输出）值时，使用extends； 向泛型代表的数据体对象写入（输入）值时，使用super； 需要同时读取和写入，使用显式类型； 例子： map(Function\u003c? super T, ? extends R\u003e) //对流中每个元素(T)类型（输入参数---消费类型）应用mapper方法，将其转换成R类型（输出参数--生产类型）. 注：从PECS原则看，Function接口定义或许令人困惑，似乎类型是反向的！不过只要记住FUnction\u003cT，R\u003e消费T并产生R,就容易理解为何super后跟T,extends后跟R! 多重边界（multiple bound）\" \u0026\" 接口作为边界的数量并无限制，但只能有一个类边界，且类边界必须居于首位！ //上边界 在读取T这个这个类型数据的时候，但不写入数据的时候i，使用上边界· //下边界 需要写入数据的时候，但不需要读取数据的时候 ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:4:0","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"3.6 关于泛型数组要提一下(参照) 看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。 也就是说下面的这个例子是不可以的： List\u003cString\u003e[] ls = new ArrayList\u003cString\u003e[10]; 而使用通配符创建泛型数组是可以的，如下面这个例子： List\u003c?\u003e[] ls = new ArrayList\u003c?\u003e[10]; 这样也是可以的： List\u003cString\u003e[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题： List\u003cString\u003e[] lsa = new List\u003cString\u003e[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List\u003cInteger\u003e li = new ArrayList\u003cInteger\u003e(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。 而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。 List\u003c?\u003e[] lsa = new List\u003c?\u003e[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List\u003cInteger\u003e li = new ArrayList\u003cInteger\u003e(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK 4. 最后 本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。 另： public class Father { void test(Object o){} } class Son\u003cT\u003e extends Father{ void test(T o){}//编译错误！ } 这段代码会报一个编译错误，both methods have same erasure, yet neither overrides the other。 这个错误的意思是，两个方法在类型擦除后，具有相同的原生类型参数列表，但是也不能覆盖另一个方法。 泛型类型在编译后，会做类型擦除，只剩下原生类型。如参数列表中的T类型会编译成Object，但是会有一个Signature。 尽管两个test方法具有相同的字节码，但是类型参数信息用 一个新的签名（signature） 属性记录在类模式中。JVM 在装载类时记录这个签名信息，并在运行时通过反射使它可用。 这就导致了这个方法既不能作为覆盖父类test方法的方法，也不能作为test方法的重载。 ","date":"2022-04-06","objectID":"/java%E6%B3%9B%E5%9E%8B/:5:0","tags":["Java"],"title":"java泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java"],"content":"了解比较器和收集器.","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"流基本操作分为中间操作和终止操作，中间操作包括filter，map，limit，sorted，distinct等，终止操作包… 比较器和收集器 流基本操作分为中间操作和终止操作，中间操作包括filter，map，limit，sorted，distinct等，终止操作包括forEach，count，collect等。今天分享有关中间操作Stream\u003cT\u003e sorted(Comparator\u003c? super T\u003e comparator);和终止操作\u003cR, A\u003e R collect(Collector\u003c? super T, A, R\u003e collector)相关内容。 比较器Comparator接口新增了多种静态和默认方法，使排序操作变得更加简单，只需要通过一系列库方法调用，就能根据一个属性对集合进行排序。收集器Collectors提供将流转换回各类集合所需的静态方法，也可以在\"下游\"使用，利用它们对分组或分区操作进行后期处理。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:0:0","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"1 比较器 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:1:0","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"1.1 比较的实现方式 Java实现对象排序的方式有两种： 自然排序：java.lang.Comparable接口 定制排序：java.util.Comparator接口 一、Comparable接口强行对实现它的每个类的对象进行整体排序，这种排序被称为类的自然排序。 实现Comparable接口必须实现重写compareTo()方法。compareTo()方法是类内部的比较器，一旦编写好了就确定了类中对象的先后次序。像String、包装类等实现了Comparable接口，重写了compareTo(Obj)方法，给出了比较两个对象大小的方式，比如进行从小到大的排序。 重写compareTo(obj)的规则： ​ 如果当前对象this大于形参对象obj，则返回正整数； ​ 如果当前对象this小于形参对象obj，则返回负整数； ​ 如果当前对象this等于形参对象obj，则返回零； 对于自定义类来说，如果需要排序，就可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序。 public class Goods implements Comparable{ private String name; private double price; @Override public int compareTo(Object o) { if (o instanceof Goods){ Goods goods = (Goods) o; // 方式一 if (this.price \u003e goods.price){ return 1; }else if(this.price \u003c goods.price){ return -1; }else { return -this.name.compareTo(goods.name); } // 方式二 // return Double.compare(this.price,goods.price); } throw new RuntimeException(\"传入的数据类型不一致\"); } public Goods(String name, double price) { this.name = name; this.price = price; } public static void main(String[] args) { Goods goods1 = new Goods(\"java攻略\", 74.6); Goods goods2 = new Goods(\"css秘密花园1\", 154.6); Goods goods3 = new Goods(\"java从入门到精髓\", 54.6); Goods goods4 = new Goods(\"算法\", 24.6); Goods goods5 = new Goods(\"研究生英语阅读教程\", 94.6); Goods goods6 = new Goods(\"新中特\", 64.6); Object[] objects = {goods1,goods2,goods3,goods4,goods5,goods6}; Arrays.sort(objects); for (Object s : objects) { System.out.println(s); } } } 实现了Comparable接口的类，可以和自己比较，就意味着该类支持排序。 实现Comparable接口的对象列表（比如list集合）和数组可以通过 Collections.sort 或**Arrays.sort**进行自动排序。 二、实现Comparator接口，只是实现一种比较方式，是类外部的比较器。当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不是想要的比较操作，那么就可以考虑使用Comparator的对象来排序。Comparator是比较器接口，如果需要控制某个类的次序，但该类本身不支持排序(即没有实现Comparable接口)，那么就可以建立一个**“该类的比较器”**来进行排序，这个“比较器”只需要实现Comparator接口即可。 总结：简单情况来说如果是实现一类大量比较器操作建议实现comparable接口，而只是临时或只使用一次建议使用comparator接口。在流的中间操作使用**Stream\u003cT\u003e sorted(Comparator\u003c? super T\u003e comparator)**。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:1:1","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"1.2 比较器功能方法 compare(T o1, T o2) 方法，比较o1和o2的大小； int compare(T o1, T o2) 如果方法返回正整数，则表示o1大于o2； 如果返回负整数，则表示o1小于o2； 如果返回0，则表示o1等于o2； 1.一个类实现Comparator接口并重写compare() CompareDemoImplement package com.example.comp_coll.Comparator; import java.io.Serializable; import java.util.Comparator; import java.util.List; class AgeComparator implements Comparator\u003cStudent\u003e, Serializable { private static final long serialVersionUID = 1L; @Override public int compare(Student s1, Student s2) { return s1.getAge() - s2.getAge(); } } class NameComparator implements Comparator\u003cStudent\u003e, Serializable { private static final long serialVersionUID = 1L; @Override public int compare(Student s1, Student s2) { return s1.getName().compareTo(s2.getName()); } } public class CompareDemoImplement { public static void main(String[] args) { List\u003cStudent\u003e list = Student.getStudentList(); System.out.println(\"--- Sort Students by age ---\"); AgeComparator ageComparator = new AgeComparator(); List\u003cStudent\u003e collect1 = list.stream().sorted(ageComparator).collect(Collectors.toList()); System.out.println(collect1); System.out.println(\"--- Sort Students by name ---\"); Comparator nameComparator = new NameComparator(); Object collect2 = list.stream().sorted(nameComparator).collect(Collectors.toList()); System.out.println(collect2); } } 输出 --- Sort Students by age --- [Aam \u003c-\u003e 18, Zhyam \u003c-\u003e 21, Eohan \u003c-\u003e 22] --- Sort Students by name --- [Aam \u003c-\u003e 18, Eohan \u003c-\u003e 22, Zhyam \u003c-\u003e 21] 2. 使用lambda表达式定义compare Comparator\u003cStudent\u003e ageComp = (s1, s2) -\u003e s1.getAge() - s2.getAge(); Comparator\u003cStudent\u003e nameComp = (s1, s2) -\u003e s1.getName().compareTo(s2.getName()); 示例CompareDemo public class CompareDemo { public static void main(String[] args) { List\u003cStudent\u003e list = Student.getStudentList(); System.out.println(\"--- Sort Students by name ---\"); // Comparator\u003cStudent\u003e nameComp = new Comparator\u003cStudent\u003e() { // @Override // public int compare(Student s1, Student s2) { // return s1.getName().compareTo(s2.getName()); // } // }; // lambda表达式 Comparator\u003cStudent\u003e nameComp = (s1, s2) -\u003e s1.getName().compareTo(s2.getName()); // stream.sorted排序 List\u003cStudent\u003e listAfterNameSorted = list.stream().sorted(nameComp).collect(Collectors.toList()); System.out.println(listAfterNameSorted); list.forEach(s -\u003e System.out.println(\"list.sort排序前：\"+s)); // list.sort(nameComp);//具有破坏性，会破坏原始数据，不满足函数式编程的不可变性 // list.forEach(s -\u003e System.out.println(\"list.sort排序后：\"+s)); Comparator\u003cStudent\u003e ageComp = (s1, s2) -\u003e s1.getAge() - s2.getAge(); System.out.println(\"--- Sort Students by age ---\"); List\u003cStudent\u003e listAfterAgeSorted = list.stream().sorted(ageComp).collect(Collectors.toList()); System.out.println(listAfterAgeSorted); } } 输出 --- Sort Students by name --- [Aam \u003c-\u003e 18, Eohan \u003c-\u003e 22, Zhyam \u003c-\u003e 21] list.sort排序前：Aam \u003c-\u003e 18 list.sort排序前：Zhyam \u003c-\u003e 21 list.sort排序前：Eohan \u003c-\u003e 22 list.sort排序后：Aam \u003c-\u003e 18 list.sort排序后：Eohan \u003c-\u003e 22 list.sort排序后：Zhyam \u003c-\u003e 21 --- Sort Students by age --- [Aam \u003c-\u003e 18, Zhyam \u003c-\u003e 21, Eohan \u003c-\u003e 22] 注意：Arrays.sort方法返回void，这种排序是破坏性的，会修改所提供的集合。不符合Java 8函数式编程的不可变性(immutability)。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:1:2","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"1.3 利用比较器实现排序 我们可以使用Stream.sorted、Collections.sort、List.sort和Arrays.sort方法来使用我们的比较器。 CompareDemoSorted package com.example.comp_coll.Comparator; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.List; public class CompareDemoSorted { public static void main(String[] args) { List\u003cStudent\u003e list = Student.getStudentList(); Comparator\u003cStudent\u003e ageComp = (s1, s2) -\u003e s1.getAge() - s2.getAge(); Comparator\u003cStudent\u003e nameComp = (s1, s2) -\u003e s1.getName().compareTo(s2.getName()); // Stream.sorted返回一个由这个流的元素组成的流，根据提供的比较器进行排序。 System.out.println(\"--- Stream.sorted Students by age ---\"); list.stream().sorted(ageComp).forEach(s -\u003e System.out.println(s)); System.out.println(\"--- Stream.sorted Students by name ---\"); list.stream().sorted(nameComp).forEach(s -\u003e System.out.println(s)); // Collections.sort根据给定的比较器实例对指定的列表进行排序。 System.out.println(\"--- Collections.sort Students by age ---\"); Collections.sort(list, ageComp); list.forEach(s -\u003e System.out.println(s)); System.out.println(\"--- Collections.sort Students by name ---\"); Collections.sort(list, nameComp); list.forEach(s -\u003e System.out.println(s)); // List.sort根据给定的比较器实例对这个列表进行排序。 System.out.println(\"--- List.sort Students by age ---\"); list.sort(ageComp); list.forEach(s -\u003e System.out.println(s)); System.out.println(\"--- List.sort Students by name ---\"); list.sort(nameComp); list.forEach(s -\u003e System.out.println(s)); // Arrays.sort根据指定比较器产生的顺序对指定的对象数组进行排序。 Student st1 = new Student(\"Ram\", 18); Student st2 = new Student(\"Shyam\",22); Student st3 = new Student(\"Mohan\",19); Student[] array = {st1, st2, st3}; System.out.println(\"--- Arrays.sort Students by age ---\"); Arrays.sort(array, ageComp); for (Student s : array) { System.out.println(s); } System.out.println(\"--- Arrays.sort Students by name ---\"); Arrays.sort(array, nameComp); for (Student s : array) { System.out.println(s); } } } 注意：Collections.sort、List.sort和Arrays.sort方法返回void，这种排序是破坏性的，会修改所提供的集合。不符合Java 8函数式编程的不可变性(immutability)。所以，Java 为java.util.Comparator接口新增了多种静态和默认方法，是排序变得更加的简单，只需要用过一系列库的调用，就可以对POJO集合进行排序。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:1:3","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"==1.4 Comparator比较器的方法== 在java8中，比较器接口定义了一些静态和默认方法，将利用比较器对集合和Map进行排序。 1.reversed reversed是Java比较器功能接口的默认方法。reversed返回一个比较器，该比较器强制执行反向排序。声明如下： default Comparator\u003cT\u003e reversed() 要使用reversed方法，我们需要实例化我们的比较器并调用该方法。 reversed将返回新的比较器实例，该实例将强加给该比较器反向排序。 @Test public void ComparatorReversedDemo(){ List\u003cStudent\u003e list = Student.getStudentList();//[Aam \u003c-\u003e 18, Zhyam \u003c-\u003e 21, Eohan \u003c-\u003e 22] System.out.println(list); Comparator\u003cStudent\u003e ageComparator = (s1, s2) -\u003e s1.getAge() - s2.getAge(); List\u003cStudent\u003e list1 = list.stream().sorted(ageComparator.reversed()).collect(Collectors.toList()); System.out.println(list1); System.out.println(\"\\n-----------\"); List\u003cStudent\u003e list2 = list.stream().sorted(Comparator.comparing(Student::getAge).reversed()).collect(Collectors.toList()); System.out.println(list2); } 2.reverseOrder reverseOrder是一个静态方法，返回比较器，对对象集合进行反向自然排序。Comparator.reverseOrder反转了自然排序。它在内部调用Collections.reverseOrder()并返回比较器实例。查找Comparator.reverseOrder的Java源代码。 public static \u003cT extends Comparable\u003c? super T\u003e\u003e Comparator\u003cT\u003e reverseOrder() { return Collections.reverseOrder(); } 示例： @Test public void ComparatorReverseOrderDemo(){ List\u003cStudent\u003e stdList = Student.getStudentList(); List\u003cStudent\u003e collect = stdList.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); System.out.println(collect); } 3.naturalOrder naturalOrder是比较器功能接口的静态方法。Comparator.naturalOrder方法返回一个比较器，该比较器以自然顺序比较可比较的对象。对于自然排序，一个类需要实现Comparable并定义compareTo方法。一个对象的集合按照自然排序的compareTo方法进行排序。像Integer、String和Date这样的Java类实现了Comparable接口，并覆盖了其compareTo方法，它们以词汇表(lexicographic-order)排序。 从Java源代码中找到naturalOrder方法声明。 static \u003cT extends Comparable\u003c? super T\u003e\u003e Comparator\u003cT\u003e naturalOrder() 示例： @Test public void ComparatorNaturalOrderDemo(){ List\u003cInteger\u003e numList = Arrays.asList(12, 10, 15, 8, 11); List\u003cInteger\u003e collect1 = numList.stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList()); System.out.println(collect1); System.out.println(\"-----------\"); List\u003cStudent\u003e stdList = Student.getStudentList(); List\u003cStudent\u003e collect2 = stdList.stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList()); System.out.println(collect2); } 4.nullsFirst nullsFirst是比较器功能接口的静态方法。Comparator.nullsFirst方法返回一个对null友好的比较器，它认为null小于非null。 从Java源代码中找到它的声明。 static \u003cT\u003e Comparator\u003cT\u003e nullsFirst(Comparator\u003c? super T\u003e comparator) 找到由nullsFirst方法返回的比较器工作原理。 空元素被认为是小于非空元素的。 当两个元素都是空的时候，那么它们就被认为是相等的。 当两个元素都是非空的时候，指定的比较器决定了顺序。 如果指定的比较器是空的，那么返回的比较器认为所有非空的元素是相等的。 示例： // nullsFirst方法返回一个对null友好的比较器，它认为null小于非null @Test public void NullsFirstDemo(){ Student s1 = new Student(\"Xam\", 18); Student s2 = new Student(\"Zhyam\", 22); Student s3 = new Student(\"Yohan\", 17); System.out.println(\"-------Case1: One null----------\"); List\u003cStudent\u003e list = Arrays.asList(s1, s2, null, s3); List\u003cStudent\u003e collect1 = list.stream().sorted(Comparator.nullsFirst(Comparator.comparing(Student::getName))).collect(Collectors.toList()); System.out.println(collect1);//[null, Xam \u003c-\u003e 18, Yohan \u003c-\u003e 17, Zhyam \u003c-\u003e 22] System.out.println(\"--------Case2: More than one null---------\"); list = Arrays.asList(s1, null, s2, null, s3); List\u003cStudent\u003e collect2 = list.stream().sorted(Comparator.nullsFirst(Comparator.comparing(Student::getName))).collect(Collectors.toList()); System.out.println(collect2);//[null, null, Xam \u003c-\u003e 18, Yohan \u003c-\u003e 17, Zhyam \u003c-\u003e 22] System.out.println(\"--------Case3: Reverse specified Comparator to nullsFirst---------\"); list = Arrays.asList(s1, null, s2, null, s3); List\u003cStudent\u003e collect3 = list.stream().sorted(Comparator.nullsFirst(Comparator.comparing(Student::getName).reversed())).collect(Collectors.toList()); System.out.println(collect3);//[null, null, Zhyam \u003c-\u003e 22, Yohan \u003c-\u003e 17, Xam \u003c-\u003e 18] System.out.println(\"--------Case4: Reverse Comparator returned by nullsFirst---------\"); list = Arrays.asList(s1, null, s2, null, s3); List\u003cStudent\u003e collect4 = list.stream().sorted(Comparator.nullsFirst(Comparator.comparing(Student::getName)).reversed()).collect(Collectors.toList()); System.out.println(collect4);//[Zhyam \u003c-\u003e","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:1:4","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"1.5 对映射排序 问题：希望根据键或值对Map排序 方案：使用Map.Entry接口新增的静态方法 Map接口定义的entrySet方法返回Map.Entry元素的Set。 entrySet()方法签名 Set\u003cMap.Entry\u003cK, V\u003e\u003e entrySet(); Map.Entry接口常用的方法，getKey和getValue二者分别返回与某个条目对应的键和值。Map.Entry公共静态内部接口新增的静态方法 方法 描述 comparingByKey() 返回一个比较器，它根据键的自然顺序比较 Map.Entry comparingByKey(Comparator \u003c? super K\u003e cmp) 返回一个比较器，它使用给定的Comparator并根据键比较Map.Entry comparingByValue() 返回一个比较器，它根据值的自然顺序比较Map.Entry comparingByValue(Comparator \u003c? super K\u003e cmp) 返回一个比较器，它使用给定的Comparator 并根据值比较Map.Entry // 对Map进行映射排序 @Test public void MapComparingDemo(){ List\u003cStuBasicInfo\u003e stuBasicInfos = CreatStu.CreatStudent(); Map\u003cString, Long\u003e collect = stuBasicInfos.stream().collect(Collectors.groupingBy(StuBasicInfo::getGrade, Collectors.counting())); System.out.println(collect); System.out.println(\"--------按键排序---------\"); collect.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach( e -\u003e System.out.printf(\" %s （级） 有 %2d （人） %n\",e.getKey(),e.getValue())); System.out.println(\"--------按值排序---------\"); collect.entrySet().stream() .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).forEach( e -\u003e System.out.printf(\" %s （级） 有 %2d （人） %n\",e.getKey(),e.getValue())); } 返回的Map\u003cString,Long\u003e之后，程序将提取entrySet并产生一个流。stream.sorted方法使用提供的比较器生产经过排序的流。在上例中，comparingByKey方法返回一个根据键进行排序的比较器。如果希望以键的倒序顺序排序，可以使用comparingByKey方法的重载形式，它传入比较器作为参数comparingByKey(Comparator.reverseOrder())。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:1:5","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"2 收集器 收集器的作用是对Stream中的元素进行收集而形成一个新的集合。 将流中的元素累积成一个结果，这个结果可以是数值，可以是集合，也可以是一个分组。 收集器作用于流的终止操作collect()。Collector作为Stream的collect方法的参数，Collector是一个接口，它是一个可变的汇聚操作，将输入元素累计到一个可变的结果容器中；它会在所有元素都处理完毕后，将累积的结果转换为一个最终的表示（这是一个可选操作）。Collectors本身提供了关于Collector的常见汇聚实现。 collect: 是stream流操作的最后一步终止操作，收集流最后的一个步骤，是一个方法，接受一个collector接口实现类 Collector：是一个接口，它是一个可变的汇聚操作，将输入元素累积到一个可变的结果容器中；它会在所有元素都处理完毕后，将结果转换为一个最终的表示；collect方法要接收一个实现了Collector接口的收集器，collect才能对流进行一个收集 Collectors: 本身提供了关于Collector的常见汇聚操作，Collectors的内部类CollectorImpl实现了Collector接口，是一个工具类，封装一些实现了预定义collector接口的收集器，可以直接使用。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:2:0","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"2.1 Stream.collect()收集操作 java8一般通过称为流水线的中间操作来传递流元素，并在达到终止操作后结束。Stream接口定义的collect方法就是一种终止操作，用于将流转换为集合。收集操作就是遍历stream中的元素，并进行累加处理，即归约reduction 归约的定义： A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. 后面将提到的max(),min(),count(),reduce()都属于reduction operation 动态归约的定义： A mutable reduction operation accumulates input elements into a mutable result container, such as a Collection or StringBuilder, as it processes the elements in the stream. 区别：动态归约将结果放进Collection， StringBuilder这样的动态容器中，所以称为动态归约。 归约官方文档：https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction Stream.collect方法两种重载形式 \u003cR\u003e R collect(Supplier\u003cR\u003e supplier, BiConsumer\u003cR,? super T\u003e accumulator, BiConsumer\u003cR,R\u003e combiner) \u003cR,A\u003e R collect(Collector\u003c? super T,A,R\u003e collector) 第一个方法签名：三个参数 供给者supplier：负责提供动态容器，例如Collector，StringBuilder 累加器accumulator：负责将流中的元素累积起来 合并者combiner：负责将两个容器的元素合并在一起 举例： @Test public void TestThreeColl(){ Stream\u003cString\u003e stream = Stream.of(\"hhh\", \"llll\"); ArrayList\u003cString\u003e string1 = new ArrayList\u003c\u003e(); //创建收集容器 stream.forEach(s -\u003e string1.add(s)); //对流中元素进行重复add操作，将结果加到ArrayList中 // System.out.println(string1); // // 等同于 ArrayList\u003cString\u003e string2 = stream.collect(() -\u003e new ArrayList\u003c\u003e(),//创建收集容器 (c, e) -\u003e c.add(e.toString()),//对流中元素进行重复add操作，将结果加到ArrayList中 (c1, c2) -\u003e c1.addAll(c2));//串形流进行归约操作将结果归约到一个结果容器中不需要进行子容器合并，并行流将结果归约到多个子结果容器中需要进行合并 // System.out.println(string2); } 在collect操作中传递了三个参数有点麻烦，还不如直接传递一个对象！所以就出现了第二个方法签名，使用收集器Collector来替代三参数。 第二个方法签名：collect()传入Collector作为参数，收集器执行“动态可变规约操作”，将元素累加至结果容器，得到一个集合。java.util.stream.Collector属于接口， 要实现Collector还是很麻烦的，需要实现好几个接口（也可以使用该接口中提供的of静态方法，生成Collector），于是Java提供了更简单的Collectors工具类来方便我们构建Collector。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:2:1","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"2.2 Collector收集器接口 如果Collectors工具类中的方法不能满足用户需求，用户可以手动实现Collector接口。 Collector接口 //T：表示流中每个元素的类型。 A：表示中间结果容器的类型。 R：表示最终返回的结果类型。 public interface Collector\u003cT, A, R\u003e { Supplier\u003cA\u003e supplier()//生成容器 BiConsumer\u003cA,T\u003e accumulator()//是累加元素 BinaryOperator\u003cA\u003e combiner()//是合并容器 Function\u003cA,R\u003e finisher()///是输出的结果 Set\u003cCollector.Characteristics\u003e characteristics()//返回Set的Collector.Characteristics指示此收集器的特征。 //返回一个新的Collector由给定的描述supplier， accumulator，combiner，和finisher功能。 static \u003cT,A,R\u003e Collector\u003cT,A,R\u003e of(Supplier\u003cA\u003e supplier, BiConsumer\u003cA,T\u003e accumulator, BinaryOperator\u003cA\u003e combiner, Function\u003cA,R\u003e finisher, Collector.Characteristics... characteristics) //返回一个新的Collector由给定的描述supplier， accumulator和combiner功能。 static \u003cT,R\u003e Collector\u003cT,R,R\u003e of(Supplier\u003cR\u003e supplier, BiConsumer\u003cR,T\u003e accumulator, BinaryOperator\u003cR\u003e combiner, Collector.Characteristics... characteristics) } 手动实现java.util.stream.Collector,可采用传入Collector.of的supplier、accumulator、combiner、finisher 函数提供lambda表达式或方法引用，以及其他所需的特性。 收集器使用5个函数，它们的作用是将元素累加到可变容器，并有选择性地对结果进行转换，这5个函数是supplier、accumulator、combiner、finisher、characteristics。 supplier()：使用supplier创建累加器容器。 accumulator()：使用BiConsumer\u003cA,T\u003e为累加器添加一个新的数据元素 combiner()：使用BinaryOperator\u003cA\u003e合并两个累加器容器 finisher()：使用Function\u003cA,R\u003e将累加器转换成结果容器 characteristics()：从枚举值中选择的Set\u003cCollector.Characteristics\u003e。 characteristics函数：表示Collector.Characteristics枚举的一个不可变的元素Set。三个枚举常量为CONCURRENT、IDENTITY_FINISH、UNORDERED 枚举常量 含义 CONCURRENT 表示结果容器支持多个线程在结果容器上并发的调用累加器函数 IDENTITY_FINISH 表示终止器函数返回其参数而不做任何修改 UNORDERED 表示集合操作无需保留元素的出现顺序 几种Collector方法的用法（取自javadoc） R container = collector.supplier.get(); //创建累加收集器 for(T t : data ){ collector.accumulator().accept(container, t); //将每个元素添加到累加器容器 } return collector.finisher().apply(container); //通过finisher函数将累加器容器转换为结果容器 在上例中并未出现combiner函数，如果处理的是顺序流，则不需要该函数，算法将既定方式执行。如果处理的是并行流，流将被分为多个子流，每个子流都会生成各自的累加器容器。接下来，在连接过程中使用combiner函数将多个累加器合并为一个，然后应用finisher函数。 利用collect方法返回不可修改的SortedSet //返回一个经过排序且不可修改的字符串集，它安字典排序 public SortedSet\u003cString\u003e oddLengthStringSet(String... strings){ Collector\u003cString,?,SortedSet\u003cString\u003e\u003e intoSet = Collector.of( TreeSet\u003cString\u003e::new, //Supplier：创建新的TreeSet SortedSet::add, //BiConsumer: 将每个字符串添加到TreeSet (left, right) -\u003e { // BinaryOperator： 将两个SortedSet实例合二为一 left.addAll(right); return left; }, Collections::unmodifiableSortedSet); //创建不可修改的TreeSet return Stream.of(strings) .filter(s -\u003e s.length() % 2 !=0) .collect(intoSet); } 在经过两个自定义collector案例讲解，会发现自定义收集器难度有点高，所以在java标准库中，Collectors类提供了多种用于生成收集器的便利方法，用户几乎不需要创建自定义收集器。 ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:2:2","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"==2.3 Collectors收集器工厂== Collectors本身提供了关于Collector的常见汇聚实现，Collectors的内部类CollectorImpl实现了Collector接口，Collectors本身实际上是一个工厂。下面是常用方法的介绍和代码示例 1.创建可变集合 Collectors.toList @Test public void ReduceToList() { List\u003cString\u003e list = Stream.of(\"Head\", \"First\", \"Java\", \"Sierra\", \"Bates\") .filter(s -\u003e s.length() \u003c 6) .collect(Collectors.toList()); System.out.println(list); } Collectors.toSet @Test public void ReduceToSet(){ Set\u003cString\u003e set = Stream.of(\"count\",\"max\",\"map\",\"min\",\"sum\",\"avg\",\"count\") .map( s -\u003e s.toUpperCase()) .collect(Collectors.toSet()); System.out.println(set);//会自动去重 } Collectors.toMap toMap()两参数方法签名 //两参数方法签名 static \u003cT,K,U\u003e Collector\u003cT,?,Map\u003cK,U\u003e\u003e toMap(Function\u003c? super T,? extends K\u003e keyMapper, Function\u003c? super T,? extends U\u003e valueMapper) //1、当key重复时，会抛出异常：java.lang.IllegalStateException: Duplicate key //2、当value为null时，会抛出异常：java.lang.NullPointerException 实例： @Test public void ReduceToMap1(){ List\u003cSchool\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(new School(\"a\",3)); integerList.add(new School(\"b\",3)); integerList.add(new School(\"c\",3)); integerList.add(new School(\"d\",2)); integerList.add(new School(\"e\",2)); // 两参数，key重复时会报错，value为null时会报错 Map map =integerList.stream().collect(Collectors.toMap(School::getSname,School::getNumbers)); System.out.println(map);//{a=3, b=3, c=3, d=2, e=2} } Function接口identity方法 返回一个输出跟输入一样的Lambda表达式对象 Function.identity方法签名 static \u003cT\u003e Function\u003cT,T\u003e identity() //在java标准库中的实现 static \u003cT\u003e Function\u003cT,T\u003e identity(){ return t -\u003e t; } @Test public void ReduceToMap2(){ List\u003cSchool\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(new School(\"a\",3)); integerList.add(new School(\"b\",3)); integerList.add(new School(\"c\",3)); integerList.add(new School(\"d\",2)); integerList.add(new School(\"e\",2)); //**Function接口identity方法** 返回一个输出跟输入一样的Lambda表达式对象 Map map =integerList.stream().collect(Collectors.toMap(School::getSname, Function.identity()));//{a=School{sname=a, numbers='3'}, b=School{sname=b, numbers='3'}, c=School{sname=c, numbers='3'}, d=School{sname=d, numbers='2'}, e=School{sname=e, numbers='2'}} System.out.println(map); } toMap()三参数方法签名： //第三个参数用在key值冲突的情况下：如果新元素产生的key在Map中已经出现过了，第三个参数就会定义解决的办法。 static \u003cT,K,U\u003e Collector\u003cT,?,Map\u003cK,U\u003e\u003e toMap( Function\u003c? super T,? extends K\u003e keyMapper, Function\u003c? super T,? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction) 示例： @Test public void ReduceToMap3(){ List\u003cSchool\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(new School(\"a\",3)); integerList.add(new School(\"b\",3)); integerList.add(new School(\"c\",3)); integerList.add(new School(\"d\",2)); integerList.add(new School(\"e\",2)); integerList.add(new School(\"e\",2)); Map map =integerList.stream().collect(Collectors.toMap(School::getSname,School::getNumbers,(a,b) -\u003e a + b)); System.out.println(map); } toList、toSet和toMap都是使用的默认数据类型，即List使用ArrayList，Set是HashSet。 Collectors.toCollection() 如果要使用特定的数据类型，需要使用Collectors.toCollection方法，参数为Supplier。下面以将结果归约为LinkedList为例 @Test public void ReduceToCollection(){ List\u003cString\u003e list = Stream.of(\"count\",\"max\",\"map\",\"min\",\"sum\",\"avg\") .filter(a -\u003e a.length() \u003c 4) .map( s -\u003e s.toUpperCase()) .collect(Collectors.toCollection(LinkedList::new)); System.out.println(list); System.out.println(list.getClass()); } 拓展：Stream接口还定义了一个用于创建对象数组的方法toArray，它有两种重载形式： Object[] toArray(); \u003cA\u003e A[] toArray(IntFunction\u003cA[]\u003e generator); 第一种形式返回一个包含流元素的数组，但未指定类型。第二种形式传入一个函数并生成所需要类型的新数组，数组的长度与流相同，很容易与数组构造函数引用一起使用。 // Stream.toArray() @Test public void TestArray(){ String[] strings = Stream.of(\"the waffler\", \"reverse psychologist\", \"pms avenger\") .toArray(String[]::new); for (int i = 0; i \u003c strings.length; i++) { System.out.println(strings[i]); } } 返回数组具有指定的类型，其长度与流中的元素数量匹配。 2.创建不可变集合 java.utils.Collections是集合工具类，用来对集合进行操作。Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。 Collections工具类定义了unmodifiableList,unmodifiableSet,unmodifiableMap方法用来创建不可变的列表、集合或映射 方法签名： static \u003cT\u003e List\u003cT\u003e unmodifiableList(List\u003c? extends T\u003e list) static \u003cT\u003e Set\u003cT\u003e unmodif","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:2:3","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"3 总结： 中间操作Stream.sorted() 终止操作Stream.collect() 终止操作\rComparable Comparator Collector Collectors Collections ","date":"2022-03-05","objectID":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/:3:0","tags":["Java","Stream"],"title":"比较器和收集器","uri":"/%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Java"],"content":"函数式编程和Lambda表达式.","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"函数式编程和Lambda表达式… 函数式编程/Lambda表达式 不用关心实现细节，调用系统API实现相关需求。 ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:0:0","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"Lambda表达式 eg: public static void main(String[] args) { Runnable ok = new Runnable() { @Override public void run() { System.out.println(\"ok\"); } }; new Thread(ok).start(); //jdk lambda new Thread(()-\u003e System.out.println(\"ok\")).start(); //等于 Runnable runnable = ()-\u003e System.out.println(\"ok\"); //箭头左边方法参数，右边方法执行体 Runnable runnable2 = ()-\u003e System.out.println(\"ok\"); System.out.println(runnable == runnable2);//false,每次返回新的对象实例 new Thread(runnable).start(); // Object o = (Runnable)()-\u003e System.out.println(\"ok\");//lambda表达式需要你告诉它实现的函数接口类型 Runnable runnable3 = ()-\u003e System.out.println(\"ok\"); //总结：lambda表达式返回一个指定接口类型的对象实例。 } demo: @FunctionalInterface interface Interface1{ int doubleNum(int i); default int add(int x,int y){ return x+y; } } public class LambdaDemo1 { public static void main(String[] args) { //写法 Interface1 i1 = (i)-\u003e i*2; Interface1 i2 = i -\u003e i*2; //1行默认有个return Interface1 i3 = (int i) -\u003e i*2; Interface1 i4 = (i) -\u003e{ System.out.println(\"多行写法\"); return i*2; }; i1.add(3,5); //默认方法可以使用。 } 总结： //接口里只有一个需要实现的方法 //JDK8中新增了接口特性 // 新增一个@FunctionalInterface,限制了当前接口是一个函数接口，意思是只能含有一个未实现方法（单一职责） // 接口里可以含有一个default方法，(当接口新增默认实现default的时候不用去修改已经实行此接口的类) ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:1:0","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"函数接口： interface FormatMoney{ String formatMoney(int i); } class MyMoney{ int money; public MyMoney(int money){ this.money = money; } public void printMoney(FormatMoney forM){ System.out.println(\"我的存款：\"+forM.formatMoney(money)); } public void printMoney2(Function\u003cInteger,String\u003e function){ //JDK8新提供的函数接口，只需告诉入参和出参，不用自己再去定义一个接口2.函数接口可支持链式操作 System.out.println(\"我的存款2：\"+function.apply(money)); } } public class MoneyDemo { public static void main(String[] args) { MyMoney money = new MyMoney(99999); money.printMoney(i -\u003e new DecimalFormat(\"#,###\").format(i)); money.printMoney2(i -\u003e new DecimalFormat(\"#,###\").format(i)); //函数接口链式操作 Function\u003cInteger,String\u003e function = i -\u003e new DecimalFormat(\"#,###\").format(i); money.printMoney2(function.andThen(s -\u003e \"加在前\"+s)); } 可以看出我们这里使用函数接口就不用再自己定义一个接口。（这里只需要完成一个int类型的入参和一个String类型的返回值） JDK8提供的函数接口以下： 接口 输入参数 返回类型 说明 Predicate T boolean 断言 Consumer T / 消费一个数据 Function\u003cT,R\u003e T R 输入T输出R的函数 Supplier / T 提供一个数据 UnaryOperator T T 一元函数（输入出类型相同） BiFunction\u003cT,U,R\u003e (T,U) R 2个输入的函数 BinaryOperator \u003cT,T\u003e T 二元函数（输入出类型相同） eg： Predicate\u003cInteger\u003e predicate = (i) -\u003e i\u003e0; System.out.println(predicate.test(-1)); Consumer\u003cString\u003e consumer = (s) -\u003e System.out.println(s); consumer.accept(\"yangeryiyi\"); //JDK里有些函数接口直接带了类型，不需要使用泛型类 //eg: IntConsumer intConsumer = i -\u003e System.out.println(\"带类型的函数接口\"+i); intConsumer.accept(9); 方法引用： //Consumer\u003cString\u003e consumer = (s) -\u003e System.out.println(s); //当参数s和方法体里的参数调用相同时，这里可修改为： Consumer\u003cString\u003e consumer2 = System.out::println; consumer2.accept(\"输出\"); 静态方法的引用： 类名::静态方法名 eg: class Dog{ private String name =\"狗\"; public static void bark(Dog dog){ System.out.println(dog.name+\"叫\"); } } public class demo2 { public static void main(String[] args) { Consumer\u003cDog\u003e consumer = Dog::bark; //只有一个输入参数，选择Consumer消费者 Dog dog = new Dog(); consumer.accept(dog); } 非静态方法： 实例名::方法名 构造方法： 类名::new eg： class Dog{ private String name =\"狗\"; private int food = 10; public int eat(Dog this,int num){ //默认在第一个参数会有一个this对象 System.out.println(\"吃了\"+num+\"斤狗粮\"); this.food -= num; return this.food; } } public class demo2 { public static void main(String[] args) { Dog dog = new Dog(); //非静态方法，使用对象实例的方法引用 //分析eat方法需要一个输入int，返回一个int,可以使用Function\u003cT,R\u003e Function\u003cInteger,Integer\u003e function = dog::eat; System.out.println(\"还剩\"+function.apply(8)); //以上eat方法可以发现输入输出是一样的都是int，可以改成一元函数接口UnaryOperator //这里因为是基本的Integer类型，JDK都有对应的函数接口，不用写泛型 //IntUnaryOperator u = dog::eat; u.applyAsInt(8) UnaryOperator\u003cInteger\u003e unaryOperator = dog::eat; System.out.println(\"还剩\"+unaryOperator.apply(8)); /* 实际上非静态方法也可以通过类名去使用方法引用 * JDK默认会把当前实例传入到非静态方法，参数名为this，位置是第一个 *所以eat方法这里可以看成两个入参一个出参 */ BiFunction\u003cDog,Integer,Integer\u003e biFunction = Dog::eat; System.out.println(\"还剩\"+biFunction.apply(dog,2)); //构造函数的方法引用 Dog::new //首先无参构造没有输入，但会返回一个实例，所以它是一个提供者 //如果有参构造我们就使用Function\u003cT,R\u003e就完事了 Supplier\u003cDog\u003e supplier = Dog::new; System.out.println(\"创建了新对象\"+supplier.get()); } } 类型推断： interface IMath{ int add(int x,int y); } interface IMath2{ int add(int x,int y); } public class TypeInference { public static void main(String[] args) { //普通 IMath lambda = (x,y) -\u003e x+y; //数组 IMath[] lambdas = {(x,y) -\u003e x+y}; //强转 Object lam =(IMath)(x,y) -\u003e x+y; //当有二义性时，使用强转对应的接口解决 TypeInference typeInference = new TypeInference(); typeInference.test((IMath) (x,y)-\u003e x+y); } public void test(IMath iMath){} public void test(IMath2 iMath){} } 变量引用： public class VarDemo { public static void main(String[] args) { //JDK8之前匿名内部类引用外面的变量必须申明为final，之后已经默认final了 //Java中参数传递是值传递，而不是传引用，如果不声明为final在匿名内部类中修改当前该变量会导致二义性 String str = \"等闲变却故人心\"; Consumer\u003cString\u003e consumer = s -\u003e System.out.println(s); consumer.accept(str); } } //值传递复制了一份list2到表达式里，是指这里两个list2其实都指向new ArrayList\u003c\u003e()；而传引用咋代表表达式里的list2其实是指向第一个list2. List\u003cString\u003e list2 = new ArrayList\u003c\u003e(); Consumer\u003cString\u003e consumer = s -\u003e System.out.println(s+list2); 级联表达式和柯里化： /** * 级联表达式和柯里化 * 柯里化：把多个参数的函数转换为只有一个参数的函数 * 柯里化目的:函数标准化 * */ Function\u003cInteger,Function\u003cInteger,Integer\u003e\u003e function = x-\u003e y -\u003e x+y; System.out.println(function.apply(2).apply(3)); int[] nums =","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:1:1","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"Stream流编程 eg: public class StreamDemo1 { public static void main(String[] args) { int[] nums = {1,2,3}; //外部迭代 int sum = 0; for(int i:nums){ sum += i; } System.out.println(\"The Result is \"+sum); //使用Stream的内部迭代;使用这个数据量大时相关并行操作等实现方便 //map就是中间操作（返回stream的操作） //sum就是终止操作 int sum2 = IntStream.of(nums).map(i -\u003e i*2).sum(); System.out.println(\"The Result is \"+sum2); //惰性求值 //这里会输出三次这里乘2，但我们直接IntStream.of(nums).map(StreamDemo1::doubleNum)而不去sum（）求和操作， // 那么map(StreamDemo1::doubleNum)也不会执行。 //惰性求值就是终止操作没有调用的情况下，中间操作不会执行 int sum3 = IntStream.of(nums).map(StreamDemo1::doubleNum).sum(); System.out.println(\"The Result is \"+sum3); } public static int doubleNum(int i){ System.out.println(\"这里乘2\"); i = i*2; return i; } } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:0","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"创建 相关方法 集合 Collection.stream/parallerStream 数组 Arrays.stream 数字Stream IntStream/LongStream.range/rangeClosed Random.ints/longs/doubles 自己创建 Stream.generate/iterate public class create { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); //从集合创建 list.stream(); list.parallelStream(); //从数组创建 Arrays.stream(new int[]{1, 2, 3}); //创建数字流 IntStream.of(1, 2, 3); IntStream.rangeClosed(1,10); //使用random创建一个无限流(需配套一个短路相关操作类似limit) new Random().ints().limit(10); //自己创建 Random random = new Random(); Stream.generate(()-\u003e random.nextInt()).limit(20); } } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:1","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"中间操作 相关方法\r无状态操作\rmap/mapToXxx\rflatMap/flatMapToXxx\rfilter\rpeek\runordered\r有状态操作\rdistinct\rsorted\rlimit/skip\reg：（有两个参数有状态，一个参数无状态） public static void main(String[] args) { String str =\"却道 故人 心 易变啊\"; Stream.of(str.split(\" \")).map(s -\u003e s.length()).forEach(System.out::println); //输出2 2 1 2 Stream.of(str.split(\" \")).filter(s -\u003e s.length()\u003e=2).map(s -\u003e s.length()).forEach(System.out::println);//输出2 2 2 //flatMap A元素下有B属性，B属性是个集合，最终得到所有的A元素里面的所有B属性集合 //intStream/longStream并不是Stream的子类，所以要进行装箱boxed Stream.of(str.split(\" \")).flatMap(s -\u003e s.chars().boxed()).forEach(i -\u003e System.out.println((char)i.intValue())); //peek 用于debug，是个中间操作，forEach是终止操作括号里放（System.out::println）=(s -\u003e System.out.println(s)) //结果输出每个空格拆分的字打印两次 Stream.of(str.split(\" \")).peek(s -\u003e System.out.println(s)).forEach(s -\u003e System.out.println(s)); //limit使用，主要用于无限流 //new Random().ints().forEach(System.out::println); //将会无限去打印产生的随机数 new Random().ints().filter(i -\u003e i\u003e10\u0026\u0026i\u003c30).limit(10).forEach(System.out::println); } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:2","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"终止操作 相关方法\r非短路操作\rforEach/forEachOrdered\rcollect/toArray\rreduce\rmin/max/count\r短路操作\rfindFirst/fandAny\rallMatch/anyMatch/noneMatch\reg: public static void main(String[] args) { String str = \"my name is 007\"; //关于带有ordered一般关于并行流 //m mis 070na ye为打印的结果，顺序是乱的 str.chars().parallel().forEach(i -\u003e System.out.print((char)i)); //保证了输出顺序my name is 007 str.chars().parallel().forEachOrdered(i -\u003e System.out.print((char)i)); //收集到list, Collectors收集器还可以toset等等 List\u003cString\u003e list = Stream.of(str.split(\" \")).collect(Collectors.toList()); //使用reduce拼接字符串 Optional\u003cString\u003e reduce = Stream.of(str.split(\" \")).reduce((s1, s2) -\u003e s1 + \"|\" + s2); System.out.println(reduce.orElse(\"\"));//如果reduce为空就返回空置 //带初始值的reduce,可以直接返回一个String，因为不用去做非空判断 String reduce1 = Stream.of(str.split(\" \")).reduce(\"\", (s1, s2) -\u003e s1 + \"|\" + s2); System.out.println(reduce1); //计算所有单词的总长度 Integer reduce2 = Stream.of(str.split(\" \")).map(s -\u003e s.length()).reduce(0, (s1, s2) -\u003e s1 + s2); System.out.println(reduce2); //max操作,返回最长的单词name Optional\u003cString\u003e max = Stream.of(str.split(\" \")).max((s1, s2) -\u003e s1.length() - s2.length()); System.out.println(max.get()); //短路操作findFirst使用,中断无限流肯定会有第一个值 OptionalInt first = new Random().ints().findFirst(); System.out.println(first.getAsInt()); } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:3","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"并行流 public class ParallelStream { public static void main(String[] args) throws InterruptedException { //1.调用paraller产生一个并行流 IntStream.range(1,100).parallel().peek(ParallelStream::debug).count(); //要实现先并行再串行， //实际上多次调用parallel | parallel，以最后一次调用为准，这里就是sequential串行 // IntStream.range(1,100) // .parallel().peek(ParallelStream::debug) // .sequential().peek(ParallelStream::debug) // .count(); /** * 并行流默认使用的线程池：ForkJoinPool.commonPool * 默认的线程数是 当前机器的cpu个数 * 使用System.setProperty(\"java.util.concurrent.ForkJoinPool.commin.parallelism\",\"20\");修改默认线程数 * */ //使用自己的线程池，不适用默认线程池，防止任务被阻塞 //线程名字ForkJoinPool-1 ForkJoinPool pool = new ForkJoinPool(20); pool.submit(()-\u003eIntStream.range(1,100).parallel().peek(ParallelStream::debug).count()); pool.shutdown(); //因为这里是再main函数里执行， 主函数已经退出了，而现在的线程池相当于一个守护线程，所以自动也退出了 //让主线程等待 synchronized (pool){ pool.wait(); } } public static void debug(int i){ // System.setProperty(\"java.util.concurrent.ForkJoinPool.commin.parallelism\",\"20\"); System.out.println(Thread.currentThread().getName()+\"debug\"+i); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } } //打印结果 // maindebug65 //ForkJoinPool.commonPool-worker-9debug32 //ForkJoinPool.commonPool-worker-10debug94 //。。。 } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:4","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"收集器 把流处理后的数据收集起来，到一些集合类，或者把处理后的数据再处理，例如求和等 eg; class Student { private String name; private int age; private Gender gender; private Grade grade; public Student(String name, int age, Gender gender, Grade grade) { super(); this.name = name; this.age = age; this.gender = gender; this.grade = grade; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Gender getGender() { return gender; } public void setGender(Gender gender) { this.gender = gender; } public Grade getGrade() { return grade; } public void setGrade(Grade grade) { this.grade = grade; } @Override public String toString() { return \"CollectDemo{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", gender=\" + gender + \", grade=\" + grade + '}'; } enum Gender{ MALE,FEMALE } enum Grade{ ONE,TWO,THREE,FOUR } } public class CollectDemo { public static void main(String[] args) { List\u003cStudent\u003e students = Arrays.asList( new Student(\"张三\",10, Student.Gender.MALE, Student.Grade.ONE), new Student(\"李四\",20, Student.Gender.FEMALE, Student.Grade.TWO), new Student(\"王五\",30, Student.Gender.MALE, Student.Grade.TWO) ); //得到所有学生年龄列表 //s -\u003e s.getAge() 可以修改为 Student::getAge,不会多生成一个类似lambda$0这样的函数 List\u003cInteger\u003e ages = students.stream().map(Student::getAge) .collect(Collectors.toList()); System.out.println(\"所有学生年龄\"+ages); //所有学生年龄[10, 20, 30] //统计汇总信息 IntSummaryStatistics ageSummaryStatistics = students.stream() .collect(Collectors.summarizingInt(Student::getAge)); System.out.println(\"年龄汇总信息\"+ageSummaryStatistics); //年龄汇总信息IntSummaryStatistics{count=3, sum=60, min=10, average=20.000000, max=30} //分块,按男女（特殊的分组，只有两组） Map\u003cBoolean, List\u003cStudent\u003e\u003e gender = students.stream() .collect(Collectors.partitioningBy(s -\u003e s.getGender() == Student.Gender.MALE)); System.out.println(\"男女列表\"+gender); // 男女列表{false=[CollectDemo{name='李四', age=20, gender=FEMALE, grade=TWO}], // true=[CollectDemo{name='张三', age=10, gender=MALE, grade=ONE}, CollectDemo{name='王五', age=30, gender=MALE, grade=TWO}]} //分组 Map\u003cStudent.Grade, List\u003cStudent\u003e\u003e grade = students.stream() .collect(Collectors.groupingBy(Student::getGrade)); System.out.println(\"班级分组\"+grade); //班级分组{TWO=[CollectDemo{name='李四', age=20, gender=FEMALE, grade=TWO}, CollectDemo{name='王五', age=30, gender=MALE, grade=TWO}], // ONE=[CollectDemo{name='张三', age=10, gender=MALE, grade=ONE}]} //得到所有班级学生个数 Map\u003cStudent.Grade, Long\u003e num = students.stream() .collect(Collectors.groupingBy(Student::getGrade,Collectors.counting())); System.out.println(\"班级人数\"+num); //班级人数{TWO=2, ONE=1} } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:5","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"相关原理 eg： /** * 1.所有元素链式掉用，一个元素只迭代一次（交替执行，一个元素会走完中间操作再到下一个） * 2.每个中间操作返回一个新的流，流里面有一个属性sourceStage指向同一个地方，就是head * Head -\u003e nextStage -\u003enextStage -\u003e..-\u003enull * 3.有状态操作会把无状态操作截断 * 4.并行环境下，有状态的中间操作不一定能并行操作 * 5.paraller | sequetial 这两个操作也是中间操作（也就是会返回stream）但是他们不创建流，他们只修改Head的并行标志 */ public class PrincipleStream { public static void main(String[] args) { Random random = new Random(); //随机产生数据 Stream\u003cInteger\u003e stream = Stream.generate(random::nextInt) .limit(200) //第一个无状态操作 .peek(s -\u003e System.out.println(\"peek操作\"+s)) //第二个无状态操作 .filter(s -\u003e { System.out.println(\"filter操作\"+s); return s\u003e10000; }); //终止操作 stream.count(); } //peek操作-1872745922 //filter操作-1872745922 //peek操作1728955806 //filter操作1728955806 } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:2:6","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"JDK 9 Reactive Stream 异步编程常见的问题： 超时、异常处理困难 难以重构 多个异步任务协同处理 为了解决异步编程过程中出现的种种难题，人们提出了各种各样方法来规避这些问题，这些方法称为反应式编程(Reactive Programming)，就像面向对象编程，函数式编程一样，反应式编程也是另一种编程范式。 反应式编程，本质上是对数据流或某种变化所作出的反应，但是这个变化什么时候发生是未知的，所以他是一种基于异步、回调的方式在处理问题。 对于Java程序员，Reactive Streams是一个API。Reactive Streams为我们提供了Java中的Reactive Programming的通用API。 Reactive Streams API中仅仅包含了如下四个接口： Publisher\u003cT\u003e Subscriber\u003cT\u003e Subscription Processor\u003cT,R\u003e Reactive Streams的主要目标有这两个： 管理跨异步边界的流数据交换 - 即将元素传递到另一个线程或线程池； 确保接收方不会强制缓冲任意数量的数据，为了使线程之间的队列有界，引入了回压(Back Pressure)。 回压(Back Pressure)，可以动态控制线程间消息交换的速率，避免生产者产生过多的消息，消费者消费不完等类似问题。 Reactive Streams，是一套非阻塞背压的异步数据流的API 而异步特性，是体现在每一步的处理过程中的，每一步处理都是消息驱动的，不阻塞应用程序，被动获得结果后继续进行下一步。 背压（back-pressure）是一种重要的反馈机制，使得系统得以优雅地响应负载，而不是在负载下崩溃。相反，如果下游组件比较空闲，则可以向上游组件发出信号，请求获得更多的调用。 eg: public class demo1 { public static void main(String[] args) throws InterruptedException { //定义发布者，发布的数据类型是Integer //直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口 SubmissionPublisher\u003cInteger\u003e publisher = new SubmissionPublisher\u003cInteger\u003e(); //2.定义订阅者 Subscriber\u003cInteger\u003e sb = new Subscriber\u003cInteger\u003e() { private Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { //保存订阅关系，需要用它来给发布者响应 this.subscription = subscription; //请求一个数据 this.subscription.request(1); // } @Override public void onNext(Integer item) { //接受到一个数据处理 System.out.println(\"接收到数据\"+ item); //处理完调用request再请求一个数据 this.subscription.request(1); //或者已经达到目标，调用cancel告诉发布者不用接受数据了 //this.subscription.cancel(); } @Override public void onError(Throwable throwable) { //出现异常（处理数据时产生了异常） throwable.printStackTrace(); //可以告诉发布者，不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { //发布者关闭时调用 System.out.println(\"处理完成\"); } }; //3.发布者和订阅者建立订阅关系 publisher.subscribe(sb); //4.生产数据，并发布 //这里忽略数据生产过程 int data=222; publisher.submit(data); publisher.submit(333); //5.结束后 关闭发布者 //一般放在finally中关闭 publisher.close(); //主线程延迟停止，否者数据还没有消费就退出 Thread.currentThread().join(1000); } } Processor /** * Processor,需要继承SubmissionPublisher并实现Processor接口 * 输入源数据integer，过滤掉小于0的，然后转换成字符串发布出去 */ class MyProcessor extends SubmissionPublisher\u003cString\u003e implements Flow.Processor\u003cInteger,String\u003e { private Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { //保存订阅关系，需要用它来给发布者响应 this.subscription = subscription; //请求一个数据 this.subscription.request(1); } @Override public void onNext(Integer item) { System.out.println(\"处理器接受到的数据\"+item); //过滤小于0的，发布出去 if (item \u003e 0){ this.submit(\"转换后\"+item); } //处理完调用request再请求一个数据 this.subscription.request(1); //或达到目标，调用cancel告诉发布者不再接受数据 //this.subscription.cancel(); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } } public class demo2 { public static void main(String[] args) throws InterruptedException { //1.定义发布者，发布的数据类型是Integer //直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口 SubmissionPublisher\u003cInteger\u003e publisher = new SubmissionPublisher\u003cInteger\u003e(); //2.定义处理器，对数据过滤，转换为String MyProcessor myProcessor = new MyProcessor(); //3.发布者和处理器建立订阅关系 publisher.subscribe(myProcessor); //4.定义最终订阅者，消费String类型数据 Flow.Subscriber\u003cString\u003e sb = new Flow.Subscriber\u003cString\u003e() { private Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { //保存订阅关系，需要用它来给发布者响应 this.subscription = subscription; //请求一个数据 this.subscription.request(1); // } @Override public void onNext(String item) { //接受到一个数据处理 System.out.println(\"接收到数据\"+ item); //处理完调用request再请求一个数据 this.subscription.request(1); //或者已经达到目标，调用cancel告诉发布者不用接受数据了 //this.subscription.cancel(); } @Override public void onError(Throwable throwable) { //出现异常（处理数据时产生了异常） throwable.printStackTrace(); //可以告诉发布者，不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { //发布者关闭时调用 System.out.println(\"处理完成\"); } }; //5.处理器和最终订阅者建立订阅关系 myProcessor.subscribe(sb); //6.生产数据，并发布 //这里忽略数据生产过程 // for (int i = 0; i \u003c 1000; i++) {//这个写法可以看出在消费者收到256条数据后如果没有即使消费这里的submit会阻塞 // publisher.submit(i); // } int data=222;","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:3:0","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"Spring WebFlux Spring WebFlux 是 Spring Framework 5.0中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。 Spring WebFlux 用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。 Reactive Streams是一套用于构建高吞吐量、低延迟应用的规范。而Reactor项目是基于这套规范的实现，它是一个完全非阻塞的基础，且支持背压。 Spring WebFlux基于Reactor实现了完全异步非阻塞的一套web框架，是一套响应式堆栈。 【spring-webmvc + Servlet + Tomcat】命令式的、同步阻塞的 【spring-webflux + Reactor + Netty】响应式的、异步非阻塞的 ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:4:0","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"异步servlet 同步servlet阻塞了什么？ 其实是阻塞了Tomcat 容器的Servlet线程。 异步： 不会阻塞tomcat线程，把耗时的业务操作放在独立的线程池里，那么servlet线程就可以立刻返回，去处理 其他请求 代码： 1.开启异步上下文环境 2.将耗时的业务代码放入独立的线程池中去完成 3.处理完返回 eg. @WebServlet(name = \"helloServlet\", value = \"/hello-servlet\",asyncSupported = true) public class HelloServlet extends HttpServlet { private String message; public void init() { message = \"Hello World!\"; } public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { long t1 = System.currentTimeMillis(); //开启异步 AsyncContext asyncContext = request.startAsync(); //执行业务代码,开启一个新线程去执行，不阻塞当前servlet线程 CompletableFuture.runAsync(()-\u003e { try { doSome(asyncContext,asyncContext.getRequest(),asyncContext.getResponse()); } catch (InterruptedException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }); System.out.println(\"用时：\"); System.out.println(System.currentTimeMillis()-t1); } } private void doSome(AsyncContext asyncContext, ServletRequest request, ServletResponse response) throws IOException, InterruptedException { TimeUnit.SECONDS.sleep(5); response.getWriter().append(\"done\"); //业务代码处理完毕 asyncContext.complete(); } } //webflux Reactor = stream + reactive stream public class ReactorDemo { public static void main(String[] args) { //Mono 0-1个元素 //Flux 0-N个元素 String[] str = {\"1\",\"2\",\"3\"}; Subscriber\u003cInteger\u003e sb = new Subscriber\u003cInteger\u003e() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { //保存订阅关系，需要用它来给发布者响应 this.subscription = subscription; //请求一个数据 this.subscription.request(2); } @Override public void onNext(Integer item) { //接受到一个数据处理 System.out.println(\"接收到数据\"+ item); //处理完调用request再请求一个数据 // this.subscription.request(2); //或者已经达到目标，调用cancel告诉发布者不用接受数据了 // this.subscription.cancel(); } @Override public void onError(Throwable throwable) { //出现异常（处理数据时产生了异常） throwable.printStackTrace(); //可以告诉发布者，不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { //发布者关闭时调用 System.out.println(\"处理完成\"); } }; //JDK8的stream Flux.fromArray(str).map(s -\u003e Integer.parseInt(s)) //最终操作 //JDK9的reactive stream .subscribe(sb); } } eg. @RestController @Slf4j public class TestController { @GetMapping(\"/1\") private String get() { log.info(\"get1--start\"); String a = createStr(); log.info(\"get1--end\"); return a; } @GetMapping(\"/2\") private Mono\u003cString\u003e get2() { log.info(\"get2--start\"); Mono\u003cString\u003e mo = Mono.fromSupplier(()-\u003e createStr()); log.info(\"get2--end\"); return mo; } private String createStr() { try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } return \"等闲变却\"; } } 在第一个例子中请求的线程会阻塞5秒，而第二个例子直接执行后面的代码 //Mono 0-1个元素 //Flux 0-N个元素 Flux的使用（会像流一样输出flux-data—1-5） @GetMapping(value = \"/3\", produces = \"text/event-stream\") private Flux\u003cString\u003e get3() { Flux\u003cString\u003e result = Flux.fromStream(IntStream.range(1,5).mapToObj(i -\u003e { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return \"flux-data---\"+i; })); return result; } SSE public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { //这两个头一定要设置 response.setContentType(\"text/event-stream\"); response.setCharacterEncoding(\"UTF-8\"); for (int i = 0; i \u003c 5; i++) { //指定格式:data: + 数据 +2个回车 response.getWriter().write(\"data:\" +i +\"\\n\\n\"); //另一种写法② response.getWriter().write(\"event:me\\n\"); response.getWriter().flush(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } } 前端写法： //依赖H5 var sse = new EventSource(\"HelloServlet\"); sse.onmessage =function(e){ console.log(\"message\",e.data,e) } //或② sse.addEventListener(\"me\",function(e){ console.log(\"me message\",e.data,e) }) //关闭自动重连 //在函数体里写sse.close(); if(e.data ==3){ sse.close(); } ","date":"2022-01-05","objectID":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/:4:1","tags":["Java","Stream"],"title":"函数式编程和Lambda表达式","uri":"/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"描述","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"在 Java 中提供了许多关于文件的操作，如 File 类，该类用来封装一个路径，这个路径可以是绝对路径，也可以是相对路径 文件IO ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:0:0","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"1 File 类 在 Java 中提供了许多关于文件的操作，如 File 类，该类用来封装一个路径，这个路径可以是绝对路径，也可以是相对路径。这个路径可以是一个文件，也可以是一个目录，通过 File 类封装完成后，可以对这些文件或目录进行一些常规操作。 ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:1:0","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"1.1 构造方法 方法 功能 File(String pathname) 通过指定的一个字符串类型的文件路径来创建一个新的 File 对象 File(String parent, String child) 根据指定的一个字符串类型的父路径和一个字符串类型的子路径（包括文件名称）创建一个 File 对象 ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:1:1","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"1.2 常用方法 方法 功能 boolean exists() 判断 File 对象对应的文件或目录是否存在，若存在则返回 true，否则返回 false boolean delete() 删除 File 对象对应的文件或目录，若删除成功则返回 true，否则返回 false boolean createNewFile() 当对象对应的文件不存在时，该方法将新建一个此 File 对象所指定的新文件，若创建成功则返回 true， 否则返回 false String getName() 返回 File 对象表示的文件或文件夹的名称 String getPath() 返回 File 对象对应的路径 String getAbsolutePath() 返回 File 对象对应的绝对路径 String getParent() 返回 File 对象对应目录的父目录 boolean canRead() 判断 File 对象对应的文件或目录是否可读，若可读则返回true，反之返回false boolean canWrite() 判断 File 对象对应的文件或目录是否可写，若可写则返回true，反之返回false boolean isFile() 判断 File 对象对应的是否是文件（不是目录），若是文件则返回true，反之返回false boolean isDirectory() 判断 File 对象对应的是否是目录（不是文件），若是目录则返回true，反之返回false boolean isAbsolute() 判断 File 对象对应的文件或目录是否是绝对路径 long lastModified() 返回1970年1月1日0时0分0秒到文件最后修改时间的毫秒值 long length() 返回文件内容的长度 String[] list() 列出指定目录的全部内容，只是列出名称 String[] list(FilenameFilter filter) 接收一个 FilenameFilter 参数，通过该参数可以只列出符合条件的文件 File[] listFiles() 返回一个包含了 File 对象所有子文件和子目录的 File 数组 示例： File file = new File(\"E:\\\\TestIO\\\\file\\\\file.txt\"); System.out.println(\"文件名称:\" + file.getName()); System.out.println(\"文件的路径:\" + file.getPath()); System.out.println(\"文件的绝对路径:\" + file.getAbsolutePath()); System.out.println(\"文件的父路径:\" + file.getParent()); System.out.println(file.canRead() ? \"文件可读\" : \"文件不可读\"); System.out.println(file.canWrite() ? \"文件可写\" : \"文件不可写\"); System.out.println(file.isFile() ? \"是一个文件\" : \"不是一个文件\"); System.out.println(file.isDirectory() ? \"是一个目录\" :\"不是一个目录\"); System.out.println(file.isAbsolute() ? \"是绝对路径\" : \"不是绝对路径\"); System.out.println(\"最后修改时间为:\" + file.lastModified()); System.out.println(\"文件大小为:\" + file.length() + \" bytes\"); // System.out.println(\"是否成功删除文件\"+file.delete()); ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:1:2","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"1.3 遍历目录下的文件 使用 File 类中的 list() 方法遍历某个指定目录下的所有文件名称。 public static void forEachFileInDir() { File file = new File(\"E:\\\\TestIO\\\\file\"); if (file.isDirectory()) { String[] fileNames = file.list(); Arrays.stream(fileNames) .forEach(System.out::println); } } public static void forEachFileInDir2() { File file = new File(\"E:\\\\TestIO\\\\file\"); List\u003cString\u003e fileList = new ArrayList\u003c\u003e(); process(file, fileList); System.out.println(fileList.toString()); } private static void process(File file, List\u003cString\u003e list) { File[] listFiles = file.listFiles(); for (File f : listFiles) { list.add(f.getName()); if (f.isDirectory()) { process(f, list); } } } ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:1:3","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"1.4 删除文件及目录 在操作文件时，经常需要删除一个目录下的某个文件或者整个文件夹，这时可以使用File类的delete()方法来实现，在使用该方法时需要判断当前目录下是否存在文件，如果存在则需要先删除内部文件，然后再删除空的文件夹。 public static void testDeleteDir() { File file = new File(\"E:\\\\TestIO\\\\fileDelete\"); deleteDir(file); } private static void deleteDir(File file) { File[] listFiles = file.listFiles(); for (File f : listFiles) { if (f.isDirectory()) { deleteDir(f); } f.delete(); } file.delete(); } ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:1:4","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"2 Paths 类 Paths 类是一个工具类，它的作用是将一个路径封装成 Path 对象，以便于在 Files 工具类中使用。 通常使用 Path.get() 方法完成对一个路径的封装，示例： Path path = Paths.get(\"E:\\\\TestIO\\\\Paths\\\\Path.txt\"); ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:2:0","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"2.1 常用方法 方法 功能 boolean isAbsolute() 该路径是否是绝对路径 boolean endsWith(String other) 该路径是否以给定字符串结束 ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:2:1","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"3 Files 类 Files 类提供了处理文件和目录，以及读取文件和写入文件的静态方法。可以用它创建和删除路径、复制文件、检查路径是否存在等。此外，Files 类还拥有创建流对象的方法。 ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:3:0","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"3.1 常用方法 方法 功能 long size(Path path) 返回文件大小 boolean isDirectory(Path path) 是否是文件夹 boolean isExecutable(Path path) 是否是可执行文件 boolean isHidden(Path path) 是否是隐藏的 boolean exists(Path path) 该文件/文件夹是否存在 boolean notExists(Path path) 该文件/文件夹是否不存在 boolean isReadable(Path path) 是否可读 boolean isWritable(Path path) 是否可写 createFile(Path filePath) 创建文件，只能是文件，不能是文件夹。如果已存在同名文件，会报错 createDirectory(Path dirPath) 创建文件夹。如果已存在同名文件夹，会报错 createTempFile(String prefix, String suffix) 在OS的临时文件夹中创建一个临时文件 createTempFile(Path dir, String prefix, String suffix) 在指定的目录下创建一个临时文件。prefix是文件名前缀，suffix是文件名后缀，一般是扩展名，比如“.zip”。中间会使用系统生成的一个随机数。返回该临时文件的Path对象（绝对路径）。文件名：前缀 + 随机数 + 后缀 createTempDirectory(String prefix) 在OS的临时文件夹中创建一个临时文件夹 createTempDirectory(Path dir, String prefix) 在指定的目录下创建一个临时文件夹。文件夹名：前缀+一个系统生成的随机数 Files.copy(Path src, Path target) 复制文件，如果存在同名的目标文件，会报错 Files.copy(Path src, Path target , StandardCopyOption.REPLACE_EXISTING) 如果存在同名的目标文件，会替换。只能是文件，不能是文件夹，要复制文件夹需要递归复制子文件、子文件夹。目标文件名可与原文件名不同。 Files.move(Path src, Path target) 剪切，如果目标已存在，会报错 Files.move(Path src, Path target , StandardCopyOption.REPLACE_EXISTING) 如果目标已存在，会替换。可以是文件、文件夹。 在copy()、move()操作中：如果Path的中间部分路径有不存在的，会报错，并不会自动创建。比如复制一张图片，目标是\"D:\\test\\1.png\" ，如果test不存在，会报错。剪切是一种特殊的复制，先复制，复制完成后再删除原文件/文件夹。 Files.delete(Path path) 删除文件、空目录。如果不存在，会报错 Files.deleteIfExists(Path path) 存在才删除，不存在时不会报错。 只能删除文件、空目录。如果该文件夹下包含子文件、子目录，即便子目录是空的，也会报错。要删除有内容的文件夹，需要递归删除子文件、子文件夹。 ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:3:1","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"3.3 写文件 使用 Files.write() 方法向文件中写入数据。 Path path = Paths.get(\"E:\\\\TestIO\\\\files\\\\a.txt\"); List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"写文件!\"); Files.write(path, list, StandardOpenOption.APPEND, StandardOpenOption.CREATE); // StandardOpenOption.APPEND 追加写文件 // StandardOpenOption.CREATE 如果文件不存在，则创建文件 ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:3:2","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"3.4 读文件 使用 Files.readAllLines() 方法从文本中读取数据。 Path path = Paths.get(\"E:\\\\TestIO\\\\files\\\\a.txt\"); List\u003cString\u003e list = Files.readAllLines(path); System.out.println(list); 使用 Files.lines() 方法 Path path = Paths.get(\"E:\\\\TestIO\\\\files\\\\a.txt\"); Stream\u003cString\u003e lines = Files.lines(path); lines.forEach(System.out::println); 使用 Files.newBufferedReader().lines() 方法 Path path = Paths.get(\"E:\\\\TestIO\\\\files\\\\a.txt\"); BufferedReader br = Files.newBufferedReader(path); br.lines().forEach(System.out::println); ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:3:3","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"3.5 list()、walk()、find()的使用 Java8中，为 java.nio.file.Files 类添加了新的静态方法。这些方法返回的都是流接口 Stream。 方法 返回类型 lines Stream list Stream walk Stream find Stream Files.list(Paths.get(\"E:\\\\TestIO\\\\books\")) .forEach(System.out::println); Files.list() 方法是非递归的，意味着使用该方法只能访问一个目录下的文件夹或者文件，而不能访问子目录。 要实现递归的访问，可以使用 Files.walk() 方法，该方法可以递归的访问给定的目录，返回一个Path流 Files.walk(Paths.get(\"E:\\\\TestIO\\\\books\")) .forEach(System.out::println); Files.find() 方法在遍历文件树的时候遇到的每个文件都会通过 BiPredicate 去判断，如果 BiPredicate 为 返回true，则相应的 Path 对象将包含在返回的流中。 Files.find(Paths.get(\"E:\\\\TestIO\\\\books\"), Integer.MAX_VALUE, (path, attr) -\u003e { return attr.isRegularFile() \u0026\u0026 path.toString().endsWith(\".txt\"); }) .forEach(System.out::println); ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:3:4","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"3.6 递归删除文件及文件夹 使用 Files.walk() 方法进行递归的删除文件夹 filesDelete 以及它子文件夹、文件。 Path path = Paths.get(\"E:\\\\TestIO\\\\filesDelete\"); try { Files.walk(path) .sorted(Comparator.reverseOrder()) .map(Path::toFile) .forEach(File::delete); } catch (IOException e) { e.printStackTrace(); } 使用 Files.find() 方法进行递归删除名字含 b 的文件和文件夹。 Path path = Paths.get(\"E:\\\\TestIO\\\\filesDelete\"); try { Files.find(path, Integer.MAX_VALUE, (p, attr) -\u003e { return p.toFile().getName().contains(\"b\"); }) .sorted(Comparator.reverseOrder()) .map(Path::toFile) .forEach(File::delete); } catch (IOException e) { e.printStackTrace(); } ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:3:5","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"使用 try-with-resources Java的一大特性就是 JVM 会对内部资源实现自动回收，但是 JVM 对外部资源（调用了底层操作系统的资源）的引用却无法自动回收，例如数据库连接、网络连接以及输入输出 IO 流等。这些连接就需要我们手动去关闭，不然会导致外部资源泄露以及文件被异常占用等。 传统的手动释放外部资源一般放在 try-catch-finally 代码块中，因为 finally 代码块中的语句肯定是会被执行的，这就保证了外部资源最后一定会被释放。同时考虑到 finally 代码块中也可能出现异常，finally 代码块中也有一个 try-catch。传统释放外部资源方法写法如下： FileInputStream fis = null; try { fis = new FileInputStream(new File(\"E:\\\\TestIO\\\\lines.txt\")); System.out.println(fis.read()); } catch (IOException e) { e.printStackTrace(); } finally { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } JDK1.7 之后有了 try-with-resource 处理机制。首先被关闭的资源需要实现 Closeable 或者 AutoCloseable 接口。写法为： try(被关闭的资源) { } catch() { } try-with-resources 代码块中可以声明一个或多个资源。程序执行完后会自动释放该资源。实现了 java.lang.AutoCloseabe 或 java.io.Closeable 的所有对象都可以声明。 使用 try-with-resources 改写上面的示例： try ( Stream\u003cString\u003e lines = Files.lines(Paths.get(\"E:\\\\TestIO\\\\lines.txt\")) ) { lines.forEach(System.out::println); } try ( Stream\u003cString\u003e lines = Files.newBufferedReader(Paths.get(\"E:\\\\TestIO\\\\lines.txt\")).lines() ) { lines.forEach(System.out::println); } try ( FileInputStream fis = new FileInputStream(new File(\"E:\\\\TestIO\\\\lines.txt\")) ) { System.out.println(fis.read()); } catch (IOException e) { e.printStackTrace(); } try ( FileInputStream fis = new FileInputStream(new File(\"E:\\\\TestIO\\\\lines.txt\")); FileOutputStream fos = new FileOutputStream(new File(\"E:\\\\TestIO\\\\linesCopy.txt\")) ) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { fos.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } ","date":"2021-11-10","objectID":"/%E6%96%87%E4%BB%B6io/:4:0","tags":["Java","IO"],"title":"Java文件IO","uri":"/%E6%96%87%E4%BB%B6io/"},{"categories":["Java"],"content":"了解网络编程.","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"Spring WebFlux 是一个异步非阻塞式 IO 模型. 一 网络编程概述 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"1.1 软件结构 C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序有QQ等软件。 B/S结构：Browser/Server结构，是指浏览器和服务器结构。常见的浏览器有谷歌、火狐等。 两种结构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"1.2 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路上行驶的汽车一定要遵守交通规则一样。这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。(比如，我用QQ给另外一个人发送消息，我们双方都得遵守网络通信协议，消息才能发送出去) TCP/IP协议：传输控制协议/因特网互联协议（Transmission Control Protocol/Internet Protocol）。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和数据链路层，每层分别负责不同的通信功能。 链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组的数据发送到目标计算机或者网络。 传输层：主要使网络程序进行通信，在进行网络通信时，我们可以使用两种协议，一种是TCP协议，一种是UDP协议。 应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"1.3 协议分类 UDP：用户数据报协议（User Datagram Protocol）。数据报是网络传输的基本单位。UDP是无连接通信协议，即在数据传输时，数据的发送端和接受端不建立逻辑连接。简单来说，主机1向主机2发送数据时，不会确认主机2是否存在，就会发送数据；同样主机2在收到数据时，也不会向主机1反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频数据传输。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。 特点：每个数据报的大小限制在64kb以内，超出这个范围就不能发送了。 TCP：传输控制协议（Transmission Control Protocol）。TCP协议是面向连接的通信协议，即在数据传输之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠的无差错的数据传输。 在TCP连接中必须明确客户端与服务器端，由客户端向服务器端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到的连接请求。 第三次握手，客户端再次向服务端发送确认消息，确认连接。整个交互过程如下图所示： ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"1.4 网络编程三要素 （一）协议 ​ 协议：计算机网络通信必须遵守的规则，上面已经介绍过了。 （二）IP地址 （三）端口号 二 IP地址 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"2.1 概念 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"2.2 分类 IPV4 IPV6 地址长度 IPV4协议具有32位（4字节）地址长度 IPv6协议具有128位（16字节）地址长度 格式 IPv4 地址的文本格式为 a.b.c.d 的形式，例如192.168.2.2 。其中a、b、c、d都是0~255范围内的十进制整数 IPv6 地址的文本格式为 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，例如 2001:0bb2:aaaa:0015:0000:0000:1aaa:1312，其中每个 x 都是十六进制数 数量 共有43亿，30亿在北美，4亿在亚洲 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"2.3 类型 A类IP地址的范围：1.0.0.1—127.255.255.254 （1）10.X.X.X 是私有地址（私有地址就是在互联网上不使用，而被用在局域网中的地址） （2）127.X.X.X 是保留地址，用作循环测试用的。 B类：128.0.0.1—191.255.255.254 172.16.0.0—172.31.255.255是私有地址 C类：192.0.0.1—223.255.255.254 192.168.X.X 是私有地址 D类：224.0.0.1—239.255.255.254 E类：240.0.0.1—247.255.255.254 在A类地址中，10.0.0.0 到 10.255.255.255 是私有地址（私有地址就是在互联网上不使用，而被用在局域网络中的地址） 在B类地址中，172.16.0.0 到 172.31.255.255 是私有地址。 在C类地址中，192.168.0.0 到 192.168.255.255 是私有地址。 常用命令： 查看本机IP地址： ipconfig ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"2.4 InetAddress类 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"2.4.1 InetAddress概述 ​ 它是Java中IP地址的类，该类对象代表一个ip对象。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:1","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"2.4.2 常用方法 获取 InetAddress 对象 // 根据主机名或者IP地址的字符串得到IP对象 public static InetAddress getByName(String host) 获得IP对象的IP字符串 public String getHostAddress() 获得IP对象的主机名称 public String getHostName() 演示： package com.xpc.ip; import java.net.InetAddress; import java.net.UnknownHostException; /** * @ClassName TestInetAddress * @Description TODO * @Author XiaoPengCheng * @Date 2021-10-12 19:52 * @Version 1.0 */ public class TestInetAddress { public static void main(String[] args) throws UnknownHostException { // 创建IP对象 // InetAddress inetAddress = InetAddress.getByName(\"10.13.254.254\"); InetAddress inetAddress = InetAddress.getByName(\"ComputerOfXiao\"); // 通过IP对象获得主机名称、IP地址 System.out.println(inetAddress.getHostAddress()); System.out.println(inetAddress.getHostName()); } } 三 端口 不同的进程有不同的端口号，端口号是用来区分一台机器上不同的应用程序的。 端口号是由两个字节组成，被规定 TCP，UDP：65535*2，例：tcp:80，udp:80（TCP和UDP传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据五元组**{传输协议，源IP，目的IP，源端口，目的端口}**判断接收者的。 （一）分类 **公有端口：**0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telnet：23 程序注册端口（分配给用户或者程序）：1024~49151 Tomcat：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 （二）DOS命令查看端口 查看所有端口： netstat -ano 查看指定端口： netstat -ano|findstr \"端口号\" 杀死进程（根据进程号）： taskkill /pid 14396 -t -f ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:2","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"URL 1）简介 URL（Uniform Resource Locator）中文名为统一资源定位符，咱们的网页地址也是一种URL。表示为互联网上的资源，如网页或者 FTP 地址。我们可以使用URL很方便的定位到一个资源，URL 可以分为如下几个部分。 protocol://host:port/path?query#fragment protocol(协议)可以是 HTTP、HTTPS、FTP 和 File，port 为端口号，path为文件路径及文件名。 当然本地文件也可以使用URL来表示： file:///D:/a.txt 2）URL 类方法 序号 方法描述 1 public URL(String protocol, String host, int port, String file) throws MalformedURLException 通过给定的参数(协议、主机名、端口号、文件名)创建URL。 2 public URL(String protocol, String host, String file) throws MalformedURLException 使用指定的协议、主机名、文件名创建URL，端口使用协议的默认端口。 3 public URL(String url) throws MalformedURLException 通过给定的URL字符串创建URL 4 public URL(URL context, String url) throws MalformedURLException 使用基地址和相对URL创建 URL类中包含了很多方法用于访问URL的各个部分，具体方法及描述如下： 序号 方法 描述 1 public String getPath() 返回URL路径部分。 4 public int getPort() 返回URL端口部分 5 public int getDefaultPort() 返回协议的默认端口号。 6 public String getProtocol() 返回URL的协议 7 public String getHost() 返回URL的主机 8 public String getFile() 返回URL文件名部分 10 public URLConnection openConnection() throws IOException 打开一个URL连接，并运行客户端访问资源。 访问文件 public static void main(String[] args) throws IOException { URL resource = new URL(\"file:///D:/a.txt\"); URLConnection urlConnection = resource.openConnection(); InputStream inputStream = urlConnection.getInputStream(); byte[] buf = new byte[1024]; int len; while ((len = inputStream.read(buf)) != -1){ System.out.println(new String(buf,0,len)); } } 文件下载 public static void main(String[] args) throws IOException { URL url = new URL(\"https://down.qq.com/qqweb/PCQQ/PCQQ_EXE/PCQQ2021.exe\"); URLConnection urlConnection = url.openConnection(); InputStream inputStream = urlConnection.getInputStream(); OutputStream outputStream = new FileOutputStream(\"D:/QQ.exe\"); byte[] bytes = new byte[1024]; int len; while ((len = inputStream.read(bytes)) != -1){ outputStream.write(bytes,0,len); } } 四 Socket ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:9:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"4.1 概述 ​ 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符 ，这个标识符就是套接字。所谓套接字(Socket)，就是对网络中不同主机上的进程之间进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"4.2 Socket机制 五 TCP网络编程和UDP网络编程 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.1 TCP网络编程 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.1.1 概述 TCP通信能实现两台计算机之间的数据交互，通信的两端要严格区分客户端（Client）与服务端（Server）。 （1）两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。 （2）在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket类表示。创建Socket对象，向服务端发送连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:1","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.1.2 Socket类 （1）构造方法摘要 ​ public Socket(String host, int port)：创建套接字对象并将其连接到指定主机上的指定端口号。 （2）常用方法摘要 public InputStream getInputStream()： 返回此套接字的输入流。 public OutputStream getOutputStream()：返回此套接字的输出流。 public void close()：关闭此套接字。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:2","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.1.3 ServerSocket类 （1）构造方法摘要 ​ public ServerSocket(int port)：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 （2）常用方法摘要 ​ public Socket accept()：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:3","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.1.4 通信模型 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:4","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.1.5 案例演示 客户端： package com.xpc.tcp; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; /** * @ClassName TCPClientDemo1 * @Description TODO * @Author XiaoPengCheng * @Date 2021-10-14 17:01 * @Version 1.0 */ // 客户端 public class TCPClientDemo1 { public static void main(String[] args) { OutputStream os = null; Socket socket = null; // InputStream is = null; // ByteArrayOutputStream baos = null; try { // 1. 创建一个socket连接 socket = new Socket(\"127.0.0.1\", 9999); // 2. 获取一个输出流，用于写出要发出的数据 os = socket.getOutputStream(); // 3. 写出数据 os.write(\"你好，我是客户端！\".getBytes()); // // ==================== 解析回复================ // socket.shutdownOutput(); // is = socket.getInputStream(); // baos = new ByteArrayOutputStream(); // byte[] buffer = new byte[1024]; // int len; // while ((len=is.read(buffer))!=-1){ // baos.write(buffer, 0, len); // } // System.out.println(\"收到了来自服务器的消息：\" + baos.toString()); } catch (Exception e) { e.printStackTrace(); } finally { // 4. 关闭资源 // if(baos!=null){ // try { // baos.close(); // } catch (IOException e) { // e.printStackTrace(); // } // } // if(is!=null){ // try { // is.close(); // } catch (IOException e) { // e.printStackTrace(); // } // } if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务端： package com.xpc.tcp; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; /** * @ClassName TCPServerDemo1 * @Description TODO * @Author XiaoPengCheng * @Date 2021-10-14 17:02 * @Version 1.0 */ // 服务端 public class TCPServerDemo1 { public static void main(String[] args) { ByteArrayOutputStream baos = null; InputStream is = null; Socket socket = null; ServerSocket serverSocket = null; // OutputStream os = null; try { // 1. 创建服务端的ServerSocket，指明自己的端口号 serverSocket = new ServerSocket(9999); // 2. 等待客户端连接过来 socket= serverSocket.accept(); // 3. 获取socket的输入流，用来读取客户端的消息 is = socket.getInputStream(); // 4. 使用字节数组输出流，读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1){ baos.write(buffer, 0, len); } System.out.println(\"收到了来自于客户端\"+socket.getInetAddress().getHostName() +\"的消息：\"+baos.toString()); // // ===================================回复================================= // os = socket.getOutputStream(); // os.write(\"你好，我是服务端。\".getBytes()); } catch (Exception e) { e.printStackTrace(); } finally { // 关闭资源 // if (os != null) { // try { // os.close(); // } catch (IOException e) { // e.printStackTrace(); // } // } if (baos != null) { try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if (serverSocket != null) { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:5","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.2 UDP网络编程 从技术意义上来讲，只有TCP才会分Server和Client。对于UDP来说，严格意义上，并没有所谓的Server和Client。 java.net包给我们提供了两个类DatagramSocket（此类表示用于发送和接收数据报的套接字）和DatagramPacket（该类表示数据报的数据包） ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:0","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.2.1 DatagramSocket （1）构造方法摘要 public DatagramSocket()：构造数据报套接字并将其绑定到本地主机上的任何可用端口。 public DatagramSocket(int port)：构造数据报套接字并将其绑定到本地主机上的指定端口。 public DatagramSocket(int port, InetAddress laddr)：创建一个数据报套接字，绑定到指定的地址。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:1","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.2.2 DatagramPacket （1）构造方法摘要 public DatagramPacket(byte[] buf, int offset, int length)：构造一个DatagramPacket用于接收指定长度的数据报包到缓冲区中。 public DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)：构造用于发送指定长度的数据报包到指定主机的指定端口号上。 （2）常用方法摘要 byte[] getData()：返回数据报包中的数据。 InetAddress getAddress()：返回该数据报发送或接收数据报的计算机的IP地址。 int getLength()：返回要发送的数据的长度或接收到的数据的长度。 ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:2","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Java"],"content":"5.2.3 案例演示 发送端： package com.xpc.udp; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; /** * @ClassName UDPSender * @Description TODO * @Author XiaoPengCheng * @Date 2021-10-15 19:37 * @Version 1.0 */ public class UDPSender { public static void main(String[] args) { DatagramSocket socket = null; try { // 1. 创建一个Socket socket = new DatagramSocket(); // 2. 创建一个包（要发送给谁） String msg = \"你好啊！\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, 9090); // 3. 发送包 socket.send(packet); } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null) socket.close(); } } } 接收端： package com.xpc.udp; import java.net.DatagramPacket; import java.net.DatagramSocket; /** * @ClassName UDPReceiver * @Description TODO * @Author XiaoPengCheng * @Date 2021-10-15 19:59 * @Version 1.0 */ public class UDPReceiver { public static void main(String[] args) { DatagramSocket socket = null; try { // 1. 创建一个socket，开放端口 socket = new DatagramSocket(9090); // 2. 创建一个包接收数据 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); // 3. 接收数据 socket.receive(packet); // 将数据包转换为字符串输出 String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(packet.getAddress().getHostAddress() + \": \" + msg); } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null) socket.close(); } } } 六 小结 （一）基于Socket的TCP编程 服务器程序的工作过程包含以下四个基本的步骤： 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept()：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。 调用 该Socket类对象的 getOutputStream() 和getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收。 关闭ServerSocket和Socket对象。 客户端程序的工作过程包含以下步骤： 创建Socket：根据指定服务端的IP地址和端口号构造Socket对象。 获取Socket的输入/输出流：使用getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输。 对 Socket 进行读/写操作 关闭 Socket （二）基于Socket的UDP编程 发送端程序的工作过程包含以下步骤： 创建DatagramSocket 实例 创建DatagramPacket实例：将数据放在DatagramPacket对象中，并指定接收方的IP地址和端口号。 发送数据：通过DatagramSocket实例的send()发送数据。 关闭socket 接收端程序的工作过程包含以下步骤： 构造DatagramSocket实例，指定本地端口。 创建DatagramPacket实例：用来接收数据。 接收数据：通过DatagramSocket实例的receive()接收。 关闭socket ","date":"2021-11-05","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:3","tags":["Java","Socket"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":" 而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。 ","date":"2022-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 Lup","uri":"/about/"}]